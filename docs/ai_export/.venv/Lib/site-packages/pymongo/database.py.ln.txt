    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Database level operations."""
   16: from __future__ import annotations
   17: 
   18: from copy import deepcopy
   19: from typing import (
   20:     TYPE_CHECKING,
   21:     Any,
   22:     Generic,
   23:     Mapping,
   24:     MutableMapping,
   25:     NoReturn,
   26:     Optional,
   27:     Sequence,
   28:     TypeVar,
   29:     Union,
   30:     cast,
   31:     overload,
   32: )
   33: 
   34: from bson.codec_options import DEFAULT_CODEC_OPTIONS, CodecOptions
   35: from bson.dbref import DBRef
   36: from bson.timestamp import Timestamp
   37: from pymongo import _csot, common
   38: from pymongo.aggregation import _DatabaseAggregationCommand
   39: from pymongo.change_stream import DatabaseChangeStream
   40: from pymongo.collection import Collection
   41: from pymongo.command_cursor import CommandCursor
   42: from pymongo.common import _ecoc_coll_name, _esc_coll_name
   43: from pymongo.errors import CollectionInvalid, InvalidName, InvalidOperation
   44: from pymongo.operations import _Op
   45: from pymongo.read_preferences import ReadPreference, _ServerMode
   46: from pymongo.typings import _CollationIn, _DocumentType, _DocumentTypeArg, _Pipeline
   47: 
   48: if TYPE_CHECKING:
   49:     import bson
   50:     import bson.codec_options
   51:     from pymongo.client_session import ClientSession
   52:     from pymongo.mongo_client import MongoClient
   53:     from pymongo.pool import Connection
   54:     from pymongo.read_concern import ReadConcern
   55:     from pymongo.server import Server
   56:     from pymongo.write_concern import WriteConcern
   57: 
   58: 
   59: def _check_name(name: str) -> None:
   60:     """Check if a database name is valid."""
   61:     if not name:
   62:         raise InvalidName("database name cannot be the empty string")
   63: 
   64:     for invalid_char in [" ", ".", "$", "/", "\\", "\x00", '"']:
   65:         if invalid_char in name:
   66:             raise InvalidName("database names cannot contain the character %r" % invalid_char)
   67: 
   68: 
   69: _CodecDocumentType = TypeVar("_CodecDocumentType", bound=Mapping[str, Any])
   70: 
   71: 
   72: class Database(common.BaseObject, Generic[_DocumentType]):
   73:     """A Mongo database."""
   74: 
   75:     def __init__(
   76:         self,
   77:         client: MongoClient[_DocumentType],
   78:         name: str,
   79:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
   80:         read_preference: Optional[_ServerMode] = None,
   81:         write_concern: Optional[WriteConcern] = None,
   82:         read_concern: Optional[ReadConcern] = None,
   83:     ) -> None:
   84:         """Get a database by client and name.
   85: 
   86:         Raises :class:`TypeError` if `name` is not an instance of
   87:         :class:`str`. Raises :class:`~pymongo.errors.InvalidName` if
   88:         `name` is not a valid database name.
   89: 
   90:         :param client: A :class:`~pymongo.mongo_client.MongoClient` instance.
   91:         :param name: The database name.
   92:         :param codec_options: An instance of
   93:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
   94:             default) client.codec_options is used.
   95:         :param read_preference: The read preference to use. If
   96:             ``None`` (the default) client.read_preference is used.
   97:         :param write_concern: An instance of
   98:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
   99:             default) client.write_concern is used.
  100:         :param read_concern: An instance of
  101:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
  102:             default) client.read_concern is used.
  103: 
  104:         .. seealso:: The MongoDB documentation on `databases <https://dochub.mongodb.org/core/databases>`_.
  105: 
  106:         .. versionchanged:: 4.0
  107:            Removed the eval, system_js, error, last_status, previous_error,
  108:            reset_error_history, authenticate, logout, collection_names,
  109:            current_op, add_user, remove_user, profiling_level,
  110:            set_profiling_level, and profiling_info methods.
  111:            See the :ref:`pymongo4-migration-guide`.
  112: 
  113:         .. versionchanged:: 3.2
  114:            Added the read_concern option.
  115: 
  116:         .. versionchanged:: 3.0
  117:            Added the codec_options, read_preference, and write_concern options.
  118:            :class:`~pymongo.database.Database` no longer returns an instance
  119:            of :class:`~pymongo.collection.Collection` for attribute names
  120:            with leading underscores. You must use dict-style lookups instead::
  121: 
  122:                db['__my_collection__']
  123: 
  124:            Not:
  125: 
  126:                db.__my_collection__
  127:         """
  128:         super().__init__(
  129:             codec_options or client.codec_options,
  130:             read_preference or client.read_preference,
  131:             write_concern or client.write_concern,
  132:             read_concern or client.read_concern,
  133:         )
  134: 
  135:         if not isinstance(name, str):
  136:             raise TypeError("name must be an instance of str")
  137: 
  138:         if name != "$external":
  139:             _check_name(name)
  140: 
  141:         self.__name = name
  142:         self.__client: MongoClient[_DocumentType] = client
  143:         self._timeout = client.options.timeout
  144: 
  145:     @property
  146:     def client(self) -> MongoClient[_DocumentType]:
  147:         """The client instance for this :class:`Database`."""
  148:         return self.__client
  149: 
  150:     @property
  151:     def name(self) -> str:
  152:         """The name of this :class:`Database`."""
  153:         return self.__name
  154: 
  155:     def with_options(
  156:         self,
  157:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
  158:         read_preference: Optional[_ServerMode] = None,
  159:         write_concern: Optional[WriteConcern] = None,
  160:         read_concern: Optional[ReadConcern] = None,
  161:     ) -> Database[_DocumentType]:
  162:         """Get a clone of this database changing the specified settings.
  163: 
  164:           >>> db1.read_preference
  165:           Primary()
  166:           >>> from pymongo.read_preferences import Secondary
  167:           >>> db2 = db1.with_options(read_preference=Secondary([{'node': 'analytics'}]))
  168:           >>> db1.read_preference
  169:           Primary()
  170:           >>> db2.read_preference
  171:           Secondary(tag_sets=[{'node': 'analytics'}], max_staleness=-1, hedge=None)
  172: 
  173:         :param codec_options: An instance of
  174:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
  175:             default) the :attr:`codec_options` of this :class:`Collection`
  176:             is used.
  177:         :param read_preference: The read preference to use. If
  178:             ``None`` (the default) the :attr:`read_preference` of this
  179:             :class:`Collection` is used. See :mod:`~pymongo.read_preferences`
  180:             for options.
  181:         :param write_concern: An instance of
  182:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
  183:             default) the :attr:`write_concern` of this :class:`Collection`
  184:             is used.
  185:         :param read_concern: An instance of
  186:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
  187:             default) the :attr:`read_concern` of this :class:`Collection`
  188:             is used.
  189: 
  190:         .. versionadded:: 3.8
  191:         """
  192:         return Database(
  193:             self.client,
  194:             self.__name,
  195:             codec_options or self.codec_options,
  196:             read_preference or self.read_preference,
  197:             write_concern or self.write_concern,
  198:             read_concern or self.read_concern,
  199:         )
  200: 
  201:     def __eq__(self, other: Any) -> bool:
  202:         if isinstance(other, Database):
  203:             return self.__client == other.client and self.__name == other.name
  204:         return NotImplemented
  205: 
  206:     def __ne__(self, other: Any) -> bool:
  207:         return not self == other
  208: 
  209:     def __hash__(self) -> int:
  210:         return hash((self.__client, self.__name))
  211: 
  212:     def __repr__(self) -> str:
  213:         return f"Database({self.__client!r}, {self.__name!r})"
  214: 
  215:     def __getattr__(self, name: str) -> Collection[_DocumentType]:
  216:         """Get a collection of this database by name.
  217: 
  218:         Raises InvalidName if an invalid collection name is used.
  219: 
  220:         :param name: the name of the collection to get
  221:         """
  222:         if name.startswith("_"):
  223:             raise AttributeError(
  224:                 f"Database has no attribute {name!r}. To access the {name}"
  225:                 f" collection, use database[{name!r}]."
  226:             )
  227:         return self.__getitem__(name)
  228: 
  229:     def __getitem__(self, name: str) -> Collection[_DocumentType]:
  230:         """Get a collection of this database by name.
  231: 
  232:         Raises InvalidName if an invalid collection name is used.
  233: 
  234:         :param name: the name of the collection to get
  235:         """
  236:         return Collection(self, name)
  237: 
  238:     def get_collection(
  239:         self,
  240:         name: str,
  241:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
  242:         read_preference: Optional[_ServerMode] = None,
  243:         write_concern: Optional[WriteConcern] = None,
  244:         read_concern: Optional[ReadConcern] = None,
  245:     ) -> Collection[_DocumentType]:
  246:         """Get a :class:`~pymongo.collection.Collection` with the given name
  247:         and options.
  248: 
  249:         Useful for creating a :class:`~pymongo.collection.Collection` with
  250:         different codec options, read preference, and/or write concern from
  251:         this :class:`Database`.
  252: 
  253:           >>> db.read_preference
  254:           Primary()
  255:           >>> coll1 = db.test
  256:           >>> coll1.read_preference
  257:           Primary()
  258:           >>> from pymongo import ReadPreference
  259:           >>> coll2 = db.get_collection(
  260:           ...     'test', read_preference=ReadPreference.SECONDARY)
  261:           >>> coll2.read_preference
  262:           Secondary(tag_sets=None)
  263: 
  264:         :param name: The name of the collection - a string.
  265:         :param codec_options: An instance of
  266:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
  267:             default) the :attr:`codec_options` of this :class:`Database` is
  268:             used.
  269:         :param read_preference: The read preference to use. If
  270:             ``None`` (the default) the :attr:`read_preference` of this
  271:             :class:`Database` is used. See :mod:`~pymongo.read_preferences`
  272:             for options.
  273:         :param write_concern: An instance of
  274:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
  275:             default) the :attr:`write_concern` of this :class:`Database` is
  276:             used.
  277:         :param read_concern: An instance of
  278:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
  279:             default) the :attr:`read_concern` of this :class:`Database` is
  280:             used.
  281:         """
  282:         return Collection(
  283:             self,
  284:             name,
  285:             False,
  286:             codec_options,
  287:             read_preference,
  288:             write_concern,
  289:             read_concern,
  290:         )
  291: 
  292:     def _get_encrypted_fields(
  293:         self, kwargs: Mapping[str, Any], coll_name: str, ask_db: bool
  294:     ) -> Optional[Mapping[str, Any]]:
  295:         encrypted_fields = kwargs.get("encryptedFields")
  296:         if encrypted_fields:
  297:             return cast(Mapping[str, Any], deepcopy(encrypted_fields))
  298:         if (
  299:             self.client.options.auto_encryption_opts
  300:             and self.client.options.auto_encryption_opts._encrypted_fields_map
  301:             and self.client.options.auto_encryption_opts._encrypted_fields_map.get(
  302:                 f"{self.name}.{coll_name}"
  303:             )
  304:         ):
  305:             return cast(
  306:                 Mapping[str, Any],
  307:                 deepcopy(
  308:                     self.client.options.auto_encryption_opts._encrypted_fields_map[
  309:                         f"{self.name}.{coll_name}"
  310:                     ]
  311:                 ),
  312:             )
  313:         if ask_db and self.client.options.auto_encryption_opts:
  314:             options = self[coll_name].options()
  315:             if options.get("encryptedFields"):
  316:                 return cast(Mapping[str, Any], deepcopy(options["encryptedFields"]))
  317:         return None
  318: 
  319:     @_csot.apply
  320:     def create_collection(
  321:         self,
  322:         name: str,
  323:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
  324:         read_preference: Optional[_ServerMode] = None,
  325:         write_concern: Optional[WriteConcern] = None,
  326:         read_concern: Optional[ReadConcern] = None,
  327:         session: Optional[ClientSession] = None,
  328:         check_exists: Optional[bool] = True,
  329:         **kwargs: Any,
  330:     ) -> Collection[_DocumentType]:
  331:         """Create a new :class:`~pymongo.collection.Collection` in this
  332:         database.
  333: 
  334:         Normally collection creation is automatic. This method should
  335:         only be used to specify options on
  336:         creation. :class:`~pymongo.errors.CollectionInvalid` will be
  337:         raised if the collection already exists.
  338: 
  339:         :param name: the name of the collection to create
  340:         :param codec_options: An instance of
  341:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
  342:             default) the :attr:`codec_options` of this :class:`Database` is
  343:             used.
  344:         :param read_preference: The read preference to use. If
  345:             ``None`` (the default) the :attr:`read_preference` of this
  346:             :class:`Database` is used.
  347:         :param write_concern: An instance of
  348:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
  349:             default) the :attr:`write_concern` of this :class:`Database` is
  350:             used.
  351:         :param read_concern: An instance of
  352:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
  353:             default) the :attr:`read_concern` of this :class:`Database` is
  354:             used.
  355:         :param collation: An instance of
  356:             :class:`~pymongo.collation.Collation`.
  357:         :param session: a
  358:             :class:`~pymongo.client_session.ClientSession`.
  359:         :param `check_exists`: if True (the default), send a listCollections command to
  360:             check if the collection already exists before creation.
  361:         :param kwargs: additional keyword arguments will
  362:             be passed as options for the `create collection command`_
  363: 
  364:         All optional `create collection command`_ parameters should be passed
  365:         as keyword arguments to this method. Valid options include, but are not
  366:         limited to:
  367: 
  368:           - ``size`` (int): desired initial size for the collection (in
  369:             bytes). For capped collections this size is the max
  370:             size of the collection.
  371:           - ``capped`` (bool): if True, this is a capped collection
  372:           - ``max`` (int): maximum number of objects if capped (optional)
  373:           - ``timeseries`` (dict): a document specifying configuration options for
  374:             timeseries collections
  375:           - ``expireAfterSeconds`` (int): the number of seconds after which a
  376:             document in a timeseries collection expires
  377:           - ``validator`` (dict): a document specifying validation rules or expressions
  378:             for the collection
  379:           - ``validationLevel`` (str): how strictly to apply the
  380:             validation rules to existing documents during an update.  The default level
  381:             is "strict"
  382:           - ``validationAction`` (str): whether to "error" on invalid documents
  383:             (the default) or just "warn" about the violations but allow invalid
  384:             documents to be inserted
  385:           - ``indexOptionDefaults`` (dict): a document specifying a default configuration
  386:             for indexes when creating a collection
  387:           - ``viewOn`` (str): the name of the source collection or view from which
  388:             to create the view
  389:           - ``pipeline`` (list): a list of aggregation pipeline stages
  390:           - ``comment`` (str): a user-provided comment to attach to this command.
  391:             This option is only supported on MongoDB >= 4.4.
  392:           - ``encryptedFields`` (dict): **(BETA)** Document that describes the encrypted fields for
  393:             Queryable Encryption. For example::
  394: 
  395:                 {
  396:                   "escCollection": "enxcol_.encryptedCollection.esc",
  397:                   "ecocCollection": "enxcol_.encryptedCollection.ecoc",
  398:                   "fields": [
  399:                       {
  400:                           "path": "firstName",
  401:                           "keyId": Binary.from_uuid(UUID('00000000-0000-0000-0000-000000000000')),
  402:                           "bsonType": "string",
  403:                           "queries": {"queryType": "equality"}
  404:                       },
  405:                       {
  406:                           "path": "ssn",
  407:                           "keyId": Binary.from_uuid(UUID('04104104-1041-0410-4104-104104104104')),
  408:                           "bsonType": "string"
  409:                       }
  410:                     ]
  411:                 }
  412:           - ``clusteredIndex`` (dict): Document that specifies the clustered index
  413:             configuration. It must have the following form::
  414: 
  415:                 {
  416:                     // key pattern must be {_id: 1}
  417:                     key: <key pattern>, // required
  418:                     unique: <bool>, // required, must be `true`
  419:                     name: <string>, // optional, otherwise automatically generated
  420:                     v: <int>, // optional, must be `2` if provided
  421:                 }
  422:           - ``changeStreamPreAndPostImages`` (dict): a document with a boolean field ``enabled`` for
  423:             enabling pre- and post-images.
  424: 
  425:         .. versionchanged:: 4.2
  426:            Added the ``check_exists``, ``clusteredIndex``, and  ``encryptedFields`` parameters.
  427: 
  428:         .. versionchanged:: 3.11
  429:            This method is now supported inside multi-document transactions
  430:            with MongoDB 4.4+.
  431: 
  432:         .. versionchanged:: 3.6
  433:            Added ``session`` parameter.
  434: 
  435:         .. versionchanged:: 3.4
  436:            Added the collation option.
  437: 
  438:         .. versionchanged:: 3.0
  439:            Added the codec_options, read_preference, and write_concern options.
  440: 
  441:         .. _create collection command:
  442:             https://mongodb.com/docs/manual/reference/command/create
  443:         """
  444:         encrypted_fields = self._get_encrypted_fields(kwargs, name, False)
  445:         if encrypted_fields:
  446:             common.validate_is_mapping("encryptedFields", encrypted_fields)
  447:             kwargs["encryptedFields"] = encrypted_fields
  448: 
  449:         clustered_index = kwargs.get("clusteredIndex")
  450:         if clustered_index:
  451:             common.validate_is_mapping("clusteredIndex", clustered_index)
  452: 
  453:         with self.__client._tmp_session(session) as s:
  454:             # Skip this check in a transaction where listCollections is not
  455:             # supported.
  456:             if (
  457:                 check_exists
  458:                 and (not s or not s.in_transaction)
  459:                 and name in self.list_collection_names(filter={"name": name}, session=s)
  460:             ):
  461:                 raise CollectionInvalid("collection %s already exists" % name)
  462:             return Collection(
  463:                 self,
  464:                 name,
  465:                 True,
  466:                 codec_options,
  467:                 read_preference,
  468:                 write_concern,
  469:                 read_concern,
  470:                 session=s,
  471:                 **kwargs,
  472:             )
  473: 
  474:     def aggregate(
  475:         self, pipeline: _Pipeline, session: Optional[ClientSession] = None, **kwargs: Any
  476:     ) -> CommandCursor[_DocumentType]:
  477:         """Perform a database-level aggregation.
  478: 
  479:         See the `aggregation pipeline`_ documentation for a list of stages
  480:         that are supported.
  481: 
  482:         .. code-block:: python
  483: 
  484:            # Lists all operations currently running on the server.
  485:            with client.admin.aggregate([{"$currentOp": {}}]) as cursor:
  486:                for operation in cursor:
  487:                    print(operation)
  488: 
  489:         The :meth:`aggregate` method obeys the :attr:`read_preference` of this
  490:         :class:`Database`, except when ``$out`` or ``$merge`` are used, in
  491:         which case  :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`
  492:         is used.
  493: 
  494:         .. note:: This method does not support the 'explain' option. Please
  495:            use :meth:`~pymongo.database.Database.command` instead.
  496: 
  497:         .. note:: The :attr:`~pymongo.database.Database.write_concern` of
  498:            this collection is automatically applied to this operation.
  499: 
  500:         :param pipeline: a list of aggregation pipeline stages
  501:         :param session: a
  502:             :class:`~pymongo.client_session.ClientSession`.
  503:         :param kwargs: extra `aggregate command`_ parameters.
  504: 
  505:         All optional `aggregate command`_ parameters should be passed as
  506:         keyword arguments to this method. Valid options include, but are not
  507:         limited to:
  508: 
  509:           - `allowDiskUse` (bool): Enables writing to temporary files. When set
  510:             to True, aggregation stages can write data to the _tmp subdirectory
  511:             of the --dbpath directory. The default is False.
  512:           - `maxTimeMS` (int): The maximum amount of time to allow the operation
  513:             to run in milliseconds.
  514:           - `batchSize` (int): The maximum number of documents to return per
  515:             batch. Ignored if the connected mongod or mongos does not support
  516:             returning aggregate results using a cursor.
  517:           - `collation` (optional): An instance of
  518:             :class:`~pymongo.collation.Collation`.
  519:           - `let` (dict): A dict of parameter names and values. Values must be
  520:             constant or closed expressions that do not reference document
  521:             fields. Parameters can then be accessed as variables in an
  522:             aggregate expression context (e.g. ``"$$var"``). This option is
  523:             only supported on MongoDB >= 5.0.
  524: 
  525:         :return: A :class:`~pymongo.command_cursor.CommandCursor` over the result
  526:           set.
  527: 
  528:         .. versionadded:: 3.9
  529: 
  530:         .. _aggregation pipeline:
  531:             https://mongodb.com/docs/manual/reference/operator/aggregation-pipeline
  532: 
  533:         .. _aggregate command:
  534:             https://mongodb.com/docs/manual/reference/command/aggregate
  535:         """
  536:         with self.client._tmp_session(session, close=False) as s:
  537:             cmd = _DatabaseAggregationCommand(
  538:                 self,
  539:                 CommandCursor,
  540:                 pipeline,
  541:                 kwargs,
  542:                 session is not None,
  543:                 user_fields={"cursor": {"firstBatch": 1}},
  544:             )
  545:             return self.client._retryable_read(
  546:                 cmd.get_cursor,
  547:                 cmd.get_read_preference(s),  # type: ignore[arg-type]
  548:                 s,
  549:                 retryable=not cmd._performs_write,
  550:                 operation=_Op.AGGREGATE,
  551:             )
  552: 
  553:     def watch(
  554:         self,
  555:         pipeline: Optional[_Pipeline] = None,
  556:         full_document: Optional[str] = None,
  557:         resume_after: Optional[Mapping[str, Any]] = None,
  558:         max_await_time_ms: Optional[int] = None,
  559:         batch_size: Optional[int] = None,
  560:         collation: Optional[_CollationIn] = None,
  561:         start_at_operation_time: Optional[Timestamp] = None,
  562:         session: Optional[ClientSession] = None,
  563:         start_after: Optional[Mapping[str, Any]] = None,
  564:         comment: Optional[Any] = None,
  565:         full_document_before_change: Optional[str] = None,
  566:         show_expanded_events: Optional[bool] = None,
  567:     ) -> DatabaseChangeStream[_DocumentType]:
  568:         """Watch changes on this database.
  569: 
  570:         Performs an aggregation with an implicit initial ``$changeStream``
  571:         stage and returns a
  572:         :class:`~pymongo.change_stream.DatabaseChangeStream` cursor which
  573:         iterates over changes on all collections in this database.
  574: 
  575:         Introduced in MongoDB 4.0.
  576: 
  577:         .. code-block:: python
  578: 
  579:            with db.watch() as stream:
  580:                for change in stream:
  581:                    print(change)
  582: 
  583:         The :class:`~pymongo.change_stream.DatabaseChangeStream` iterable
  584:         blocks until the next change document is returned or an error is
  585:         raised. If the
  586:         :meth:`~pymongo.change_stream.DatabaseChangeStream.next` method
  587:         encounters a network error when retrieving a batch from the server,
  588:         it will automatically attempt to recreate the cursor such that no
  589:         change events are missed. Any error encountered during the resume
  590:         attempt indicates there may be an outage and will be raised.
  591: 
  592:         .. code-block:: python
  593: 
  594:             try:
  595:                 with db.watch([{"$match": {"operationType": "insert"}}]) as stream:
  596:                     for insert_change in stream:
  597:                         print(insert_change)
  598:             except pymongo.errors.PyMongoError:
  599:                 # The ChangeStream encountered an unrecoverable error or the
  600:                 # resume attempt failed to recreate the cursor.
  601:                 logging.error("...")
  602: 
  603:         For a precise description of the resume process see the
  604:         `change streams specification`_.
  605: 
  606:         :param pipeline: A list of aggregation pipeline stages to
  607:             append to an initial ``$changeStream`` stage. Not all
  608:             pipeline stages are valid after a ``$changeStream`` stage, see the
  609:             MongoDB documentation on change streams for the supported stages.
  610:         :param full_document: The fullDocument to pass as an option
  611:             to the ``$changeStream`` stage. Allowed values: 'updateLookup',
  612:             'whenAvailable', 'required'. When set to 'updateLookup', the
  613:             change notification for partial updates will include both a delta
  614:             describing the changes to the document, as well as a copy of the
  615:             entire document that was changed from some time after the change
  616:             occurred.
  617:         :param full_document_before_change: Allowed values: 'whenAvailable'
  618:             and 'required'. Change events may now result in a
  619:             'fullDocumentBeforeChange' response field.
  620:         :param resume_after: A resume token. If provided, the
  621:             change stream will start returning changes that occur directly
  622:             after the operation specified in the resume token. A resume token
  623:             is the _id value of a change document.
  624:         :param max_await_time_ms: The maximum time in milliseconds
  625:             for the server to wait for changes before responding to a getMore
  626:             operation.
  627:         :param batch_size: The maximum number of documents to return
  628:             per batch.
  629:         :param collation: The :class:`~pymongo.collation.Collation`
  630:             to use for the aggregation.
  631:         :param start_at_operation_time: If provided, the resulting
  632:             change stream will only return changes that occurred at or after
  633:             the specified :class:`~bson.timestamp.Timestamp`. Requires
  634:             MongoDB >= 4.0.
  635:         :param session: a
  636:             :class:`~pymongo.client_session.ClientSession`.
  637:         :param start_after: The same as `resume_after` except that
  638:             `start_after` can resume notifications after an invalidate event.
  639:             This option and `resume_after` are mutually exclusive.
  640:         :param comment: A user-provided comment to attach to this
  641:             command.
  642:         :param show_expanded_events: Include expanded events such as DDL events like `dropIndexes`.
  643: 
  644:         :return: A :class:`~pymongo.change_stream.DatabaseChangeStream` cursor.
  645: 
  646:         .. versionchanged:: 4.3
  647:            Added `show_expanded_events` parameter.
  648: 
  649:         .. versionchanged:: 4.2
  650:             Added ``full_document_before_change`` parameter.
  651: 
  652:         .. versionchanged:: 4.1
  653:            Added ``comment`` parameter.
  654: 
  655:         .. versionchanged:: 3.9
  656:            Added the ``start_after`` parameter.
  657: 
  658:         .. versionadded:: 3.7
  659: 
  660:         .. seealso:: The MongoDB documentation on `changeStreams <https://mongodb.com/docs/manual/changeStreams/>`_.
  661: 
  662:         .. _change streams specification:
  663:             https://github.com/mongodb/specifications/blob/master/source/change-streams/change-streams.md
  664:         """
  665:         return DatabaseChangeStream(
  666:             self,
  667:             pipeline,
  668:             full_document,
  669:             resume_after,
  670:             max_await_time_ms,
  671:             batch_size,
  672:             collation,
  673:             start_at_operation_time,
  674:             session,
  675:             start_after,
  676:             comment,
  677:             full_document_before_change,
  678:             show_expanded_events=show_expanded_events,
  679:         )
  680: 
  681:     @overload
  682:     def _command(
  683:         self,
  684:         conn: Connection,
  685:         command: Union[str, MutableMapping[str, Any]],
  686:         value: int = 1,
  687:         check: bool = True,
  688:         allowable_errors: Optional[Sequence[Union[str, int]]] = None,
  689:         read_preference: _ServerMode = ReadPreference.PRIMARY,
  690:         codec_options: CodecOptions[dict[str, Any]] = DEFAULT_CODEC_OPTIONS,
  691:         write_concern: Optional[WriteConcern] = None,
  692:         parse_write_concern_error: bool = False,
  693:         session: Optional[ClientSession] = None,
  694:         **kwargs: Any,
  695:     ) -> dict[str, Any]:
  696:         ...
  697: 
  698:     @overload
  699:     def _command(
  700:         self,
  701:         conn: Connection,
  702:         command: Union[str, MutableMapping[str, Any]],
  703:         value: int = 1,
  704:         check: bool = True,
  705:         allowable_errors: Optional[Sequence[Union[str, int]]] = None,
  706:         read_preference: _ServerMode = ReadPreference.PRIMARY,
  707:         codec_options: CodecOptions[_CodecDocumentType] = ...,
  708:         write_concern: Optional[WriteConcern] = None,
  709:         parse_write_concern_error: bool = False,
  710:         session: Optional[ClientSession] = None,
  711:         **kwargs: Any,
  712:     ) -> _CodecDocumentType:
  713:         ...
  714: 
  715:     def _command(
  716:         self,
  717:         conn: Connection,
  718:         command: Union[str, MutableMapping[str, Any]],
  719:         value: int = 1,
  720:         check: bool = True,
  721:         allowable_errors: Optional[Sequence[Union[str, int]]] = None,
  722:         read_preference: _ServerMode = ReadPreference.PRIMARY,
  723:         codec_options: Union[
  724:             CodecOptions[dict[str, Any]], CodecOptions[_CodecDocumentType]
  725:         ] = DEFAULT_CODEC_OPTIONS,
  726:         write_concern: Optional[WriteConcern] = None,
  727:         parse_write_concern_error: bool = False,
  728:         session: Optional[ClientSession] = None,
  729:         **kwargs: Any,
  730:     ) -> Union[dict[str, Any], _CodecDocumentType]:
  731:         """Internal command helper."""
  732:         if isinstance(command, str):
  733:             command = {command: value}
  734: 
  735:         command.update(kwargs)
  736:         with self.__client._tmp_session(session) as s:
  737:             return conn.command(
  738:                 self.__name,
  739:                 command,
  740:                 read_preference,
  741:                 codec_options,
  742:                 check,
  743:                 allowable_errors,
  744:                 write_concern=write_concern,
  745:                 parse_write_concern_error=parse_write_concern_error,
  746:                 session=s,
  747:                 client=self.__client,
  748:             )
  749: 
  750:     @overload
  751:     def command(
  752:         self,
  753:         command: Union[str, MutableMapping[str, Any]],
  754:         value: Any = 1,
  755:         check: bool = True,
  756:         allowable_errors: Optional[Sequence[Union[str, int]]] = None,
  757:         read_preference: Optional[_ServerMode] = None,
  758:         codec_options: None = None,
  759:         session: Optional[ClientSession] = None,
  760:         comment: Optional[Any] = None,
  761:         **kwargs: Any,
  762:     ) -> dict[str, Any]:
  763:         ...
  764: 
  765:     @overload
  766:     def command(
  767:         self,
  768:         command: Union[str, MutableMapping[str, Any]],
  769:         value: Any = 1,
  770:         check: bool = True,
  771:         allowable_errors: Optional[Sequence[Union[str, int]]] = None,
  772:         read_preference: Optional[_ServerMode] = None,
  773:         codec_options: CodecOptions[_CodecDocumentType] = ...,
  774:         session: Optional[ClientSession] = None,
  775:         comment: Optional[Any] = None,
  776:         **kwargs: Any,
  777:     ) -> _CodecDocumentType:
  778:         ...
  779: 
  780:     @_csot.apply
  781:     def command(
  782:         self,
  783:         command: Union[str, MutableMapping[str, Any]],
  784:         value: Any = 1,
  785:         check: bool = True,
  786:         allowable_errors: Optional[Sequence[Union[str, int]]] = None,
  787:         read_preference: Optional[_ServerMode] = None,
  788:         codec_options: Optional[bson.codec_options.CodecOptions[_CodecDocumentType]] = None,
  789:         session: Optional[ClientSession] = None,
  790:         comment: Optional[Any] = None,
  791:         **kwargs: Any,
  792:     ) -> Union[dict[str, Any], _CodecDocumentType]:
  793:         """Issue a MongoDB command.
  794: 
  795:         Send command `command` to the database and return the
  796:         response. If `command` is an instance of :class:`str`
  797:         then the command {`command`: `value`} will be sent.
  798:         Otherwise, `command` must be an instance of
  799:         :class:`dict` and will be sent as is.
  800: 
  801:         Any additional keyword arguments will be added to the final
  802:         command document before it is sent.
  803: 
  804:         For example, a command like ``{buildinfo: 1}`` can be sent
  805:         using:
  806: 
  807:         >>> db.command("buildinfo")
  808:         OR
  809:         >>> db.command({"buildinfo": 1})
  810: 
  811:         For a command where the value matters, like ``{count:
  812:         collection_name}`` we can do:
  813: 
  814:         >>> db.command("count", collection_name)
  815:         OR
  816:         >>> db.command({"count": collection_name})
  817: 
  818:         For commands that take additional arguments we can use
  819:         kwargs. So ``{count: collection_name, query: query}`` becomes:
  820: 
  821:         >>> db.command("count", collection_name, query=query)
  822:         OR
  823:         >>> db.command({"count": collection_name, "query": query})
  824: 
  825:         :param command: document representing the command to be issued,
  826:             or the name of the command (for simple commands only).
  827: 
  828:             .. note:: the order of keys in the `command` document is
  829:                significant (the "verb" must come first), so commands
  830:                which require multiple keys (e.g. `findandmodify`)
  831:                should be done with this in mind.
  832: 
  833:         :param value: value to use for the command verb when
  834:             `command` is passed as a string
  835:         :param check: check the response for errors, raising
  836:             :class:`~pymongo.errors.OperationFailure` if there are any
  837:         :param allowable_errors: if `check` is ``True``, error messages
  838:             in this list will be ignored by error-checking
  839:         :param read_preference: The read preference for this
  840:             operation. See :mod:`~pymongo.read_preferences` for options.
  841:             If the provided `session` is in a transaction, defaults to the
  842:             read preference configured for the transaction.
  843:             Otherwise, defaults to
  844:             :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`.
  845:         :param codec_options: A :class:`~bson.codec_options.CodecOptions`
  846:             instance.
  847:         :param session: A
  848:             :class:`~pymongo.client_session.ClientSession`.
  849:         :param comment: A user-provided comment to attach to this
  850:             command.
  851:         :param kwargs: additional keyword arguments will
  852:             be added to the command document before it is sent
  853: 
  854: 
  855:         .. note:: :meth:`command` does **not** obey this Database's
  856:            :attr:`read_preference` or :attr:`codec_options`. You must use the
  857:            ``read_preference`` and ``codec_options`` parameters instead.
  858: 
  859:         .. note:: :meth:`command` does **not** apply any custom TypeDecoders
  860:            when decoding the command response.
  861: 
  862:         .. note:: If this client has been configured to use MongoDB Stable
  863:            API (see :ref:`versioned-api-ref`), then :meth:`command` will
  864:            automatically add API versioning options to the given command.
  865:            Explicitly adding API versioning options in the command and
  866:            declaring an API version on the client is not supported.
  867: 
  868:         .. versionchanged:: 3.6
  869:            Added ``session`` parameter.
  870: 
  871:         .. versionchanged:: 3.0
  872:            Removed the `as_class`, `fields`, `uuid_subtype`, `tag_sets`,
  873:            and `secondary_acceptable_latency_ms` option.
  874:            Removed `compile_re` option: PyMongo now always represents BSON
  875:            regular expressions as :class:`~bson.regex.Regex` objects. Use
  876:            :meth:`~bson.regex.Regex.try_compile` to attempt to convert from a
  877:            BSON regular expression to a Python regular expression object.
  878:            Added the ``codec_options`` parameter.
  879: 
  880:         .. seealso:: The MongoDB documentation on `commands <https://dochub.mongodb.org/core/commands>`_.
  881:         """
  882:         opts = codec_options or DEFAULT_CODEC_OPTIONS
  883:         if comment is not None:
  884:             kwargs["comment"] = comment
  885: 
  886:         if isinstance(command, str):
  887:             command_name = command
  888:         else:
  889:             command_name = next(iter(command))
  890: 
  891:         if read_preference is None:
  892:             read_preference = (session and session._txn_read_preference()) or ReadPreference.PRIMARY
  893:         with self.__client._conn_for_reads(read_preference, session, operation=command_name) as (
  894:             connection,
  895:             read_preference,
  896:         ):
  897:             return self._command(
  898:                 connection,
  899:                 command,
  900:                 value,
  901:                 check,
  902:                 allowable_errors,
  903:                 read_preference,
  904:                 opts,
  905:                 session=session,
  906:                 **kwargs,
  907:             )
  908: 
  909:     @_csot.apply
  910:     def cursor_command(
  911:         self,
  912:         command: Union[str, MutableMapping[str, Any]],
  913:         value: Any = 1,
  914:         read_preference: Optional[_ServerMode] = None,
  915:         codec_options: Optional[bson.codec_options.CodecOptions[_CodecDocumentType]] = None,
  916:         session: Optional[ClientSession] = None,
  917:         comment: Optional[Any] = None,
  918:         max_await_time_ms: Optional[int] = None,
  919:         **kwargs: Any,
  920:     ) -> CommandCursor[_DocumentType]:
  921:         """Issue a MongoDB command and parse the response as a cursor.
  922: 
  923:         If the response from the server does not include a cursor field, an error will be thrown.
  924: 
  925:         Otherwise, behaves identically to issuing a normal MongoDB command.
  926: 
  927:         :param command: document representing the command to be issued,
  928:             or the name of the command (for simple commands only).
  929: 
  930:             .. note:: the order of keys in the `command` document is
  931:                significant (the "verb" must come first), so commands
  932:                which require multiple keys (e.g. `findandmodify`)
  933:                should use an instance of :class:`~bson.son.SON` or
  934:                a string and kwargs instead of a Python `dict`.
  935: 
  936:         :param value: value to use for the command verb when
  937:           `command` is passed as a string
  938:         :param read_preference: The read preference for this
  939:           operation. See :mod:`~pymongo.read_preferences` for options.
  940:           If the provided `session` is in a transaction, defaults to the
  941:           read preference configured for the transaction.
  942:           Otherwise, defaults to
  943:           :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`.
  944:         :param codec_options`: A :class:`~bson.codec_options.CodecOptions`
  945:           instance.
  946:         :param session: A
  947:           :class:`~pymongo.client_session.ClientSession`.
  948:         :param comment: A user-provided comment to attach to future getMores for this
  949:           command.
  950:         :param max_await_time_ms: The number of ms to wait for more data on future getMores for this command.
  951:         :param kwargs: additional keyword arguments will
  952:           be added to the command document before it is sent
  953: 
  954:         .. note:: :meth:`command` does **not** obey this Database's
  955:            :attr:`read_preference` or :attr:`codec_options`. You must use the
  956:            ``read_preference`` and ``codec_options`` parameters instead.
  957: 
  958:         .. note:: :meth:`command` does **not** apply any custom TypeDecoders
  959:            when decoding the command response.
  960: 
  961:         .. note:: If this client has been configured to use MongoDB Stable
  962:            API (see :ref:`versioned-api-ref`), then :meth:`command` will
  963:            automatically add API versioning options to the given command.
  964:            Explicitly adding API versioning options in the command and
  965:            declaring an API version on the client is not supported.
  966: 
  967:         .. seealso:: The MongoDB documentation on `commands <https://dochub.mongodb.org/core/commands>`_.
  968:         """
  969:         if isinstance(command, str):
  970:             command_name = command
  971:         else:
  972:             command_name = next(iter(command))
  973: 
  974:         with self.__client._tmp_session(session, close=False) as tmp_session:
  975:             opts = codec_options or DEFAULT_CODEC_OPTIONS
  976: 
  977:             if read_preference is None:
  978:                 read_preference = (
  979:                     tmp_session and tmp_session._txn_read_preference()
  980:                 ) or ReadPreference.PRIMARY
  981:             with self.__client._conn_for_reads(read_preference, tmp_session, command_name) as (
  982:                 conn,
  983:                 read_preference,
  984:             ):
  985:                 response = self._command(
  986:                     conn,
  987:                     command,
  988:                     value,
  989:                     True,
  990:                     None,
  991:                     read_preference,
  992:                     opts,
  993:                     session=tmp_session,
  994:                     **kwargs,
  995:                 )
  996:                 coll = self.get_collection("$cmd", read_preference=read_preference)
  997:                 if response.get("cursor"):
  998:                     cmd_cursor = CommandCursor(
  999:                         coll,
 1000:                         response["cursor"],
 1001:                         conn.address,
 1002:                         max_await_time_ms=max_await_time_ms,
 1003:                         session=tmp_session,
 1004:                         explicit_session=session is not None,
 1005:                         comment=comment,
 1006:                     )
 1007:                     cmd_cursor._maybe_pin_connection(conn)
 1008:                     return cmd_cursor
 1009:                 else:
 1010:                     raise InvalidOperation("Command does not return a cursor.")
 1011: 
 1012:     def _retryable_read_command(
 1013:         self,
 1014:         command: Union[str, MutableMapping[str, Any]],
 1015:         operation: str,
 1016:         session: Optional[ClientSession] = None,
 1017:     ) -> dict[str, Any]:
 1018:         """Same as command but used for retryable read commands."""
 1019:         read_preference = (session and session._txn_read_preference()) or ReadPreference.PRIMARY
 1020: 
 1021:         def _cmd(
 1022:             session: Optional[ClientSession],
 1023:             _server: Server,
 1024:             conn: Connection,
 1025:             read_preference: _ServerMode,
 1026:         ) -> dict[str, Any]:
 1027:             return self._command(
 1028:                 conn,
 1029:                 command,
 1030:                 read_preference=read_preference,
 1031:                 session=session,
 1032:             )
 1033: 
 1034:         return self.__client._retryable_read(_cmd, read_preference, session, operation)
 1035: 
 1036:     def _list_collections(
 1037:         self,
 1038:         conn: Connection,
 1039:         session: Optional[ClientSession],
 1040:         read_preference: _ServerMode,
 1041:         **kwargs: Any,
 1042:     ) -> CommandCursor[MutableMapping[str, Any]]:
 1043:         """Internal listCollections helper."""
 1044:         coll = cast(
 1045:             Collection[MutableMapping[str, Any]],
 1046:             self.get_collection("$cmd", read_preference=read_preference),
 1047:         )
 1048:         cmd = {"listCollections": 1, "cursor": {}}
 1049:         cmd.update(kwargs)
 1050:         with self.__client._tmp_session(session, close=False) as tmp_session:
 1051:             cursor = self._command(conn, cmd, read_preference=read_preference, session=tmp_session)[
 1052:                 "cursor"
 1053:             ]
 1054:             cmd_cursor = CommandCursor(
 1055:                 coll,
 1056:                 cursor,
 1057:                 conn.address,
 1058:                 session=tmp_session,
 1059:                 explicit_session=session is not None,
 1060:                 comment=cmd.get("comment"),
 1061:             )
 1062:         cmd_cursor._maybe_pin_connection(conn)
 1063:         return cmd_cursor
 1064: 
 1065:     def list_collections(
 1066:         self,
 1067:         session: Optional[ClientSession] = None,
 1068:         filter: Optional[Mapping[str, Any]] = None,
 1069:         comment: Optional[Any] = None,
 1070:         **kwargs: Any,
 1071:     ) -> CommandCursor[MutableMapping[str, Any]]:
 1072:         """Get a cursor over the collections of this database.
 1073: 
 1074:         :param session: a
 1075:             :class:`~pymongo.client_session.ClientSession`.
 1076:         :param filter:  A query document to filter the list of
 1077:             collections returned from the listCollections command.
 1078:         :param comment: A user-provided comment to attach to this
 1079:             command.
 1080:         :param kwargs: Optional parameters of the
 1081:             `listCollections command
 1082:             <https://mongodb.com/docs/manual/reference/command/listCollections/>`_
 1083:             can be passed as keyword arguments to this method. The supported
 1084:             options differ by server version.
 1085: 
 1086: 
 1087:         :return: An instance of :class:`~pymongo.command_cursor.CommandCursor`.
 1088: 
 1089:         .. versionadded:: 3.6
 1090:         """
 1091:         if filter is not None:
 1092:             kwargs["filter"] = filter
 1093:         read_pref = (session and session._txn_read_preference()) or ReadPreference.PRIMARY
 1094:         if comment is not None:
 1095:             kwargs["comment"] = comment
 1096: 
 1097:         def _cmd(
 1098:             session: Optional[ClientSession],
 1099:             _server: Server,
 1100:             conn: Connection,
 1101:             read_preference: _ServerMode,
 1102:         ) -> CommandCursor[MutableMapping[str, Any]]:
 1103:             return self._list_collections(conn, session, read_preference=read_preference, **kwargs)
 1104: 
 1105:         return self.__client._retryable_read(
 1106:             _cmd, read_pref, session, operation=_Op.LIST_COLLECTIONS
 1107:         )
 1108: 
 1109:     def list_collection_names(
 1110:         self,
 1111:         session: Optional[ClientSession] = None,
 1112:         filter: Optional[Mapping[str, Any]] = None,
 1113:         comment: Optional[Any] = None,
 1114:         **kwargs: Any,
 1115:     ) -> list[str]:
 1116:         """Get a list of all the collection names in this database.
 1117: 
 1118:         For example, to list all non-system collections::
 1119: 
 1120:             filter = {"name": {"$regex": r"^(?!system\\.)"}}
 1121:             db.list_collection_names(filter=filter)
 1122: 
 1123:         :param session: a
 1124:             :class:`~pymongo.client_session.ClientSession`.
 1125:         :param filter:  A query document to filter the list of
 1126:             collections returned from the listCollections command.
 1127:         :param comment: A user-provided comment to attach to this
 1128:             command.
 1129:         :param kwargs: Optional parameters of the
 1130:             `listCollections command
 1131:             <https://mongodb.com/docs/manual/reference/command/listCollections/>`_
 1132:             can be passed as keyword arguments to this method. The supported
 1133:             options differ by server version.
 1134: 
 1135: 
 1136:         .. versionchanged:: 3.8
 1137:            Added the ``filter`` and ``**kwargs`` parameters.
 1138: 
 1139:         .. versionadded:: 3.6
 1140:         """
 1141:         if comment is not None:
 1142:             kwargs["comment"] = comment
 1143:         if filter is None:
 1144:             kwargs["nameOnly"] = True
 1145: 
 1146:         else:
 1147:             # The enumerate collections spec states that "drivers MUST NOT set
 1148:             # nameOnly if a filter specifies any keys other than name."
 1149:             common.validate_is_mapping("filter", filter)
 1150:             kwargs["filter"] = filter
 1151:             if not filter or (len(filter) == 1 and "name" in filter):
 1152:                 kwargs["nameOnly"] = True
 1153: 
 1154:         return [result["name"] for result in self.list_collections(session=session, **kwargs)]
 1155: 
 1156:     def _drop_helper(
 1157:         self, name: str, session: Optional[ClientSession] = None, comment: Optional[Any] = None
 1158:     ) -> dict[str, Any]:
 1159:         command = {"drop": name}
 1160:         if comment is not None:
 1161:             command["comment"] = comment
 1162: 
 1163:         with self.__client._conn_for_writes(session, operation=_Op.DROP) as connection:
 1164:             return self._command(
 1165:                 connection,
 1166:                 command,
 1167:                 allowable_errors=["ns not found", 26],
 1168:                 write_concern=self._write_concern_for(session),
 1169:                 parse_write_concern_error=True,
 1170:                 session=session,
 1171:             )
 1172: 
 1173:     @_csot.apply
 1174:     def drop_collection(
 1175:         self,
 1176:         name_or_collection: Union[str, Collection[_DocumentTypeArg]],
 1177:         session: Optional[ClientSession] = None,
 1178:         comment: Optional[Any] = None,
 1179:         encrypted_fields: Optional[Mapping[str, Any]] = None,
 1180:     ) -> dict[str, Any]:
 1181:         """Drop a collection.
 1182: 
 1183:         :param name_or_collection: the name of a collection to drop or the
 1184:             collection object itself
 1185:         :param session: a
 1186:             :class:`~pymongo.client_session.ClientSession`.
 1187:         :param comment: A user-provided comment to attach to this
 1188:             command.
 1189:         :param encrypted_fields: **(BETA)** Document that describes the encrypted fields for
 1190:             Queryable Encryption. For example::
 1191: 
 1192:                 {
 1193:                   "escCollection": "enxcol_.encryptedCollection.esc",
 1194:                   "ecocCollection": "enxcol_.encryptedCollection.ecoc",
 1195:                   "fields": [
 1196:                       {
 1197:                           "path": "firstName",
 1198:                           "keyId": Binary.from_uuid(UUID('00000000-0000-0000-0000-000000000000')),
 1199:                           "bsonType": "string",
 1200:                           "queries": {"queryType": "equality"}
 1201:                       },
 1202:                       {
 1203:                           "path": "ssn",
 1204:                           "keyId": Binary.from_uuid(UUID('04104104-1041-0410-4104-104104104104')),
 1205:                           "bsonType": "string"
 1206:                       }
 1207:                   ]
 1208: 
 1209:                 }
 1210: 
 1211: 
 1212:         .. note:: The :attr:`~pymongo.database.Database.write_concern` of
 1213:            this database is automatically applied to this operation.
 1214: 
 1215:         .. versionchanged:: 4.2
 1216:            Added ``encrypted_fields`` parameter.
 1217: 
 1218:         .. versionchanged:: 4.1
 1219:            Added ``comment`` parameter.
 1220: 
 1221:         .. versionchanged:: 3.6
 1222:            Added ``session`` parameter.
 1223: 
 1224:         .. versionchanged:: 3.4
 1225:            Apply this database's write concern automatically to this operation
 1226:            when connected to MongoDB >= 3.4.
 1227: 
 1228:         """
 1229:         name = name_or_collection
 1230:         if isinstance(name, Collection):
 1231:             name = name.name
 1232: 
 1233:         if not isinstance(name, str):
 1234:             raise TypeError("name_or_collection must be an instance of str")
 1235:         encrypted_fields = self._get_encrypted_fields(
 1236:             {"encryptedFields": encrypted_fields},
 1237:             name,
 1238:             True,
 1239:         )
 1240:         if encrypted_fields:
 1241:             common.validate_is_mapping("encrypted_fields", encrypted_fields)
 1242:             self._drop_helper(
 1243:                 _esc_coll_name(encrypted_fields, name), session=session, comment=comment
 1244:             )
 1245:             self._drop_helper(
 1246:                 _ecoc_coll_name(encrypted_fields, name), session=session, comment=comment
 1247:             )
 1248: 
 1249:         return self._drop_helper(name, session, comment)
 1250: 
 1251:     def validate_collection(
 1252:         self,
 1253:         name_or_collection: Union[str, Collection[_DocumentTypeArg]],
 1254:         scandata: bool = False,
 1255:         full: bool = False,
 1256:         session: Optional[ClientSession] = None,
 1257:         background: Optional[bool] = None,
 1258:         comment: Optional[Any] = None,
 1259:     ) -> dict[str, Any]:
 1260:         """Validate a collection.
 1261: 
 1262:         Returns a dict of validation info. Raises CollectionInvalid if
 1263:         validation fails.
 1264: 
 1265:         See also the MongoDB documentation on the `validate command`_.
 1266: 
 1267:         :param name_or_collection: A Collection object or the name of a
 1268:             collection to validate.
 1269:         :param scandata: Do extra checks beyond checking the overall
 1270:             structure of the collection.
 1271:         :param full: Have the server do a more thorough scan of the
 1272:             collection. Use with `scandata` for a thorough scan
 1273:             of the structure of the collection and the individual
 1274:             documents.
 1275:         :param session: a
 1276:             :class:`~pymongo.client_session.ClientSession`.
 1277:         :param background: A boolean flag that determines whether
 1278:             the command runs in the background. Requires MongoDB 4.4+.
 1279:         :param comment: A user-provided comment to attach to this
 1280:             command.
 1281: 
 1282:         .. versionchanged:: 4.1
 1283:            Added ``comment`` parameter.
 1284: 
 1285:         .. versionchanged:: 3.11
 1286:            Added ``background`` parameter.
 1287: 
 1288:         .. versionchanged:: 3.6
 1289:            Added ``session`` parameter.
 1290: 
 1291:         .. _validate command: https://mongodb.com/docs/manual/reference/command/validate/
 1292:         """
 1293:         name = name_or_collection
 1294:         if isinstance(name, Collection):
 1295:             name = name.name
 1296: 
 1297:         if not isinstance(name, str):
 1298:             raise TypeError("name_or_collection must be an instance of str or Collection")
 1299:         cmd = {"validate": name, "scandata": scandata, "full": full}
 1300:         if comment is not None:
 1301:             cmd["comment"] = comment
 1302: 
 1303:         if background is not None:
 1304:             cmd["background"] = background
 1305: 
 1306:         result = self.command(cmd, session=session)
 1307: 
 1308:         valid = True
 1309:         # Pre 1.9 results
 1310:         if "result" in result:
 1311:             info = result["result"]
 1312:             if info.find("exception") != -1 or info.find("corrupt") != -1:
 1313:                 raise CollectionInvalid(f"{name} invalid: {info}")
 1314:         # Sharded results
 1315:         elif "raw" in result:
 1316:             for _, res in result["raw"].items():
 1317:                 if "result" in res:
 1318:                     info = res["result"]
 1319:                     if info.find("exception") != -1 or info.find("corrupt") != -1:
 1320:                         raise CollectionInvalid(f"{name} invalid: {info}")
 1321:                 elif not res.get("valid", False):
 1322:                     valid = False
 1323:                     break
 1324:         # Post 1.9 non-sharded results.
 1325:         elif not result.get("valid", False):
 1326:             valid = False
 1327: 
 1328:         if not valid:
 1329:             raise CollectionInvalid(f"{name} invalid: {result!r}")
 1330: 
 1331:         return result
 1332: 
 1333:     # See PYTHON-3084.
 1334:     __iter__ = None
 1335: 
 1336:     def __next__(self) -> NoReturn:
 1337:         raise TypeError("'Database' object is not iterable")
 1338: 
 1339:     next = __next__
 1340: 
 1341:     def __bool__(self) -> NoReturn:
 1342:         raise NotImplementedError(
 1343:             "Database objects do not implement truth "
 1344:             "value testing or bool(). Please compare "
 1345:             "with None instead: database is not None"
 1346:         )
 1347: 
 1348:     def dereference(
 1349:         self,
 1350:         dbref: DBRef,
 1351:         session: Optional[ClientSession] = None,
 1352:         comment: Optional[Any] = None,
 1353:         **kwargs: Any,
 1354:     ) -> Optional[_DocumentType]:
 1355:         """Dereference a :class:`~bson.dbref.DBRef`, getting the
 1356:         document it points to.
 1357: 
 1358:         Raises :class:`TypeError` if `dbref` is not an instance of
 1359:         :class:`~bson.dbref.DBRef`. Returns a document, or ``None`` if
 1360:         the reference does not point to a valid document.  Raises
 1361:         :class:`ValueError` if `dbref` has a database specified that
 1362:         is different from the current database.
 1363: 
 1364:         :param dbref: the reference
 1365:         :param session: a
 1366:             :class:`~pymongo.client_session.ClientSession`.
 1367:         :param comment: A user-provided comment to attach to this
 1368:             command.
 1369:         :param kwargs: any additional keyword arguments
 1370:             are the same as the arguments to
 1371:             :meth:`~pymongo.collection.Collection.find`.
 1372: 
 1373: 
 1374:         .. versionchanged:: 4.1
 1375:            Added ``comment`` parameter.
 1376:         .. versionchanged:: 3.6
 1377:            Added ``session`` parameter.
 1378:         """
 1379:         if not isinstance(dbref, DBRef):
 1380:             raise TypeError("cannot dereference a %s" % type(dbref))
 1381:         if dbref.database is not None and dbref.database != self.__name:
 1382:             raise ValueError(
 1383:                 "trying to dereference a DBRef that points to "
 1384:                 f"another database ({dbref.database!r} not {self.__name!r})"
 1385:             )
 1386:         return self[dbref.collection].find_one(
 1387:             {"_id": dbref.id}, session=session, comment=comment, **kwargs
 1388:         )
