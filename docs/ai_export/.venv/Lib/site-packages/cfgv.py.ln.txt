    1: from __future__ import annotations
    2: 
    3: import collections
    4: import contextlib
    5: import os.path
    6: import re
    7: import sys
    8: 
    9: 
   10: class ValidationError(ValueError):
   11:     def __init__(self, error_msg, ctx=None):
   12:         super().__init__(error_msg)
   13:         self.error_msg = error_msg
   14:         self.ctx = ctx
   15: 
   16:     def __str__(self):
   17:         out = '\n'
   18:         err = self
   19:         while err.ctx is not None:
   20:             out += f'==> {err.ctx}\n'
   21:             err = err.error_msg
   22:         out += f'=====> {err.error_msg}'
   23:         return out
   24: 
   25: 
   26: MISSING = collections.namedtuple('Missing', ())()
   27: type(MISSING).__repr__ = lambda self: 'MISSING'
   28: 
   29: 
   30: @contextlib.contextmanager
   31: def validate_context(msg):
   32:     try:
   33:         yield
   34:     except ValidationError as e:
   35:         _, _, tb = sys.exc_info()
   36:         raise ValidationError(e, ctx=msg).with_traceback(tb) from None
   37: 
   38: 
   39: @contextlib.contextmanager
   40: def reraise_as(tp):
   41:     try:
   42:         yield
   43:     except ValidationError as e:
   44:         _, _, tb = sys.exc_info()
   45:         raise tp(e).with_traceback(tb) from None
   46: 
   47: 
   48: def _dct_noop(self, dct):
   49:     pass
   50: 
   51: 
   52: def _check_optional(self, dct):
   53:     if self.key not in dct:
   54:         return
   55:     with validate_context(f'At key: {self.key}'):
   56:         self.check_fn(dct[self.key])
   57: 
   58: 
   59: def _apply_default_optional(self, dct):
   60:     dct.setdefault(self.key, self.default)
   61: 
   62: 
   63: def _remove_default_optional(self, dct):
   64:     if dct.get(self.key, MISSING) == self.default:
   65:         del dct[self.key]
   66: 
   67: 
   68: def _require_key(self, dct):
   69:     if self.key not in dct:
   70:         raise ValidationError(f'Missing required key: {self.key}')
   71: 
   72: 
   73: def _check_required(self, dct):
   74:     _require_key(self, dct)
   75:     _check_optional(self, dct)
   76: 
   77: 
   78: @property
   79: def _check_fn_recurse(self):
   80:     def check_fn(val):
   81:         validate(val, self.schema)
   82:     return check_fn
   83: 
   84: 
   85: def _apply_default_required_recurse(self, dct):
   86:     dct[self.key] = apply_defaults(dct[self.key], self.schema)
   87: 
   88: 
   89: def _remove_default_required_recurse(self, dct):
   90:     dct[self.key] = remove_defaults(dct[self.key], self.schema)
   91: 
   92: 
   93: def _apply_default_optional_recurse(self, dct):
   94:     if self.key not in dct:
   95:         _apply_default_optional(self, dct)
   96:     _apply_default_required_recurse(self, dct)
   97: 
   98: 
   99: def _remove_default_optional_recurse(self, dct):
  100:     if self.key in dct:
  101:         _remove_default_required_recurse(self, dct)
  102:         _remove_default_optional(self, dct)
  103: 
  104: 
  105: def _get_check_conditional(inner):
  106:     def _check_conditional(self, dct):
  107:         if dct.get(self.condition_key, MISSING) == self.condition_value:
  108:             inner(self, dct)
  109:         elif (
  110:                 self.condition_key in dct and
  111:                 self.ensure_absent and self.key in dct
  112:         ):
  113:             if hasattr(self.condition_value, 'describe_opposite'):
  114:                 explanation = self.condition_value.describe_opposite()
  115:             else:
  116:                 explanation = f'is not {self.condition_value!r}'
  117:             raise ValidationError(
  118:                 f'Expected {self.key} to be absent when {self.condition_key} '
  119:                 f'{explanation}, found {self.key}: {dct[self.key]!r}',
  120:             )
  121:     return _check_conditional
  122: 
  123: 
  124: def _apply_default_conditional_optional(self, dct):
  125:     if dct.get(self.condition_key, MISSING) == self.condition_value:
  126:         _apply_default_optional(self, dct)
  127: 
  128: 
  129: def _remove_default_conditional_optional(self, dct):
  130:     if dct.get(self.condition_key, MISSING) == self.condition_value:
  131:         _remove_default_optional(self, dct)
  132: 
  133: 
  134: def _apply_default_conditional_recurse(self, dct):
  135:     if dct.get(self.condition_key, MISSING) == self.condition_value:
  136:         _apply_default_required_recurse(self, dct)
  137: 
  138: 
  139: def _remove_default_conditional_recurse(self, dct):
  140:     if dct.get(self.condition_key, MISSING) == self.condition_value:
  141:         _remove_default_required_recurse(self, dct)
  142: 
  143: 
  144: def _no_additional_keys_check(self, dct):
  145:     extra = sorted(set(dct) - set(self.keys))
  146:     if extra:
  147:         extra_s = ', '.join(str(x) for x in extra)
  148:         keys_s = ', '.join(str(x) for x in self.keys)
  149:         raise ValidationError(
  150:             f'Additional keys found: {extra_s}.  '
  151:             f'Only these keys are allowed: {keys_s}',
  152:         )
  153: 
  154: 
  155: def _warn_additional_keys_check(self, dct):
  156:     extra = sorted(set(dct) - set(self.keys))
  157:     if extra:
  158:         self.callback(extra, self.keys, dct)
  159: 
  160: 
  161: Required = collections.namedtuple('Required', ('key', 'check_fn'))
  162: Required.check = _check_required
  163: Required.apply_default = _dct_noop
  164: Required.remove_default = _dct_noop
  165: RequiredRecurse = collections.namedtuple('RequiredRecurse', ('key', 'schema'))
  166: RequiredRecurse.check = _check_required
  167: RequiredRecurse.check_fn = _check_fn_recurse
  168: RequiredRecurse.apply_default = _apply_default_required_recurse
  169: RequiredRecurse.remove_default = _remove_default_required_recurse
  170: Optional = collections.namedtuple('Optional', ('key', 'check_fn', 'default'))
  171: Optional.check = _check_optional
  172: Optional.apply_default = _apply_default_optional
  173: Optional.remove_default = _remove_default_optional
  174: OptionalRecurse = collections.namedtuple(
  175:     'OptionalRecurse', ('key', 'schema', 'default'),
  176: )
  177: OptionalRecurse.check = _check_optional
  178: OptionalRecurse.check_fn = _check_fn_recurse
  179: OptionalRecurse.apply_default = _apply_default_optional_recurse
  180: OptionalRecurse.remove_default = _remove_default_optional_recurse
  181: OptionalNoDefault = collections.namedtuple(
  182:     'OptionalNoDefault', ('key', 'check_fn'),
  183: )
  184: OptionalNoDefault.check = _check_optional
  185: OptionalNoDefault.apply_default = _dct_noop
  186: OptionalNoDefault.remove_default = _dct_noop
  187: Conditional = collections.namedtuple(
  188:     'Conditional',
  189:     ('key', 'check_fn', 'condition_key', 'condition_value', 'ensure_absent'),
  190: )
  191: Conditional.__new__.__defaults__ = (False,)
  192: Conditional.check = _get_check_conditional(_check_required)
  193: Conditional.apply_default = _dct_noop
  194: Conditional.remove_default = _dct_noop
  195: ConditionalOptional = collections.namedtuple(
  196:     'ConditionalOptional',
  197:     (
  198:         'key', 'check_fn', 'default', 'condition_key', 'condition_value',
  199:         'ensure_absent',
  200:     ),
  201: )
  202: ConditionalOptional.__new__.__defaults__ = (False,)
  203: ConditionalOptional.check = _get_check_conditional(_check_optional)
  204: ConditionalOptional.apply_default = _apply_default_conditional_optional
  205: ConditionalOptional.remove_default = _remove_default_conditional_optional
  206: ConditionalRecurse = collections.namedtuple(
  207:     'ConditionalRecurse',
  208:     ('key', 'schema', 'condition_key', 'condition_value', 'ensure_absent'),
  209: )
  210: ConditionalRecurse.__new__.__defaults__ = (False,)
  211: ConditionalRecurse.check = _get_check_conditional(_check_required)
  212: ConditionalRecurse.check_fn = _check_fn_recurse
  213: ConditionalRecurse.apply_default = _apply_default_conditional_recurse
  214: ConditionalRecurse.remove_default = _remove_default_conditional_recurse
  215: NoAdditionalKeys = collections.namedtuple('NoAdditionalKeys', ('keys',))
  216: NoAdditionalKeys.check = _no_additional_keys_check
  217: NoAdditionalKeys.apply_default = _dct_noop
  218: NoAdditionalKeys.remove_default = _dct_noop
  219: WarnAdditionalKeys = collections.namedtuple(
  220:     'WarnAdditionalKeys', ('keys', 'callback'),
  221: )
  222: WarnAdditionalKeys.check = _warn_additional_keys_check
  223: WarnAdditionalKeys.apply_default = _dct_noop
  224: WarnAdditionalKeys.remove_default = _dct_noop
  225: 
  226: 
  227: class Map(collections.namedtuple('Map', ('object_name', 'id_key', 'items'))):
  228:     __slots__ = ()
  229: 
  230:     def __new__(cls, object_name, id_key, *items):
  231:         return super().__new__(cls, object_name, id_key, items)
  232: 
  233:     def check(self, v):
  234:         if not isinstance(v, dict):
  235:             raise ValidationError(
  236:                 f'Expected a {self.object_name} map but got a '
  237:                 f'{type(v).__name__}',
  238:             )
  239:         if self.id_key is None:
  240:             context = f'At {self.object_name}()'
  241:         else:
  242:             key_v_s = v.get(self.id_key, MISSING)
  243:             context = f'At {self.object_name}({self.id_key}={key_v_s!r})'
  244:         with validate_context(context):
  245:             for item in self.items:
  246:                 item.check(v)
  247: 
  248:     def apply_defaults(self, v):
  249:         ret = v.copy()
  250:         for item in self.items:
  251:             item.apply_default(ret)
  252:         return ret
  253: 
  254:     def remove_defaults(self, v):
  255:         ret = v.copy()
  256:         for item in self.items:
  257:             item.remove_default(ret)
  258:         return ret
  259: 
  260: 
  261: class Array(collections.namedtuple('Array', ('of', 'allow_empty'))):
  262:     __slots__ = ()
  263: 
  264:     def __new__(cls, of, allow_empty=True):
  265:         return super().__new__(cls, of=of, allow_empty=allow_empty)
  266: 
  267:     def check(self, v):
  268:         check_array(check_any)(v)
  269:         if not self.allow_empty and not v:
  270:             raise ValidationError(
  271:                 f"Expected at least 1 '{self.of.object_name}'",
  272:             )
  273:         for val in v:
  274:             validate(val, self.of)
  275: 
  276:     def apply_defaults(self, v):
  277:         return [apply_defaults(val, self.of) for val in v]
  278: 
  279:     def remove_defaults(self, v):
  280:         return [remove_defaults(val, self.of) for val in v]
  281: 
  282: 
  283: class Not(collections.namedtuple('Not', ('val',))):
  284:     __slots__ = ()
  285: 
  286:     def describe_opposite(self):
  287:         return f'is {self.val!r}'
  288: 
  289:     def __eq__(self, other):
  290:         return other is not MISSING and other != self.val
  291: 
  292: 
  293: class NotIn(collections.namedtuple('NotIn', ('values',))):
  294:     __slots__ = ()
  295: 
  296:     def __new__(cls, *values):
  297:         return super().__new__(cls, values=values)
  298: 
  299:     def describe_opposite(self):
  300:         return f'is any of {self.values!r}'
  301: 
  302:     def __eq__(self, other):
  303:         return other is not MISSING and other not in self.values
  304: 
  305: 
  306: class In(collections.namedtuple('In', ('values',))):
  307:     __slots__ = ()
  308: 
  309:     def __new__(cls, *values):
  310:         return super().__new__(cls, values=values)
  311: 
  312:     def describe_opposite(self):
  313:         return f'is not any of {self.values!r}'
  314: 
  315:     def __eq__(self, other):
  316:         return other is not MISSING and other in self.values
  317: 
  318: 
  319: def check_any(_):
  320:     pass
  321: 
  322: 
  323: def check_type(tp, typename=None):
  324:     def check_type_fn(v):
  325:         if not isinstance(v, tp):
  326:             typename_s = typename or tp.__name__
  327:             raise ValidationError(
  328:                 f'Expected {typename_s} got {type(v).__name__}',
  329:             )
  330:     return check_type_fn
  331: 
  332: 
  333: check_bool = check_type(bool)
  334: check_bytes = check_type(bytes)
  335: check_int = check_type(int)
  336: check_string = check_type(str, typename='string')
  337: check_text = check_type(str, typename='text')
  338: 
  339: 
  340: def check_one_of(possible):
  341:     def check_one_of_fn(v):
  342:         if v not in possible:
  343:             possible_s = ', '.join(str(x) for x in sorted(possible))
  344:             raise ValidationError(
  345:                 f'Expected one of {possible_s} but got: {v!r}',
  346:             )
  347:     return check_one_of_fn
  348: 
  349: 
  350: def check_regex(v):
  351:     try:
  352:         re.compile(v)
  353:     except re.error:
  354:         raise ValidationError(f'{v!r} is not a valid python regex')
  355: 
  356: 
  357: def check_array(inner_check):
  358:     def check_array_fn(v):
  359:         if not isinstance(v, (list, tuple)):
  360:             raise ValidationError(
  361:                 f'Expected array but got {type(v).__name__!r}',
  362:             )
  363: 
  364:         for i, val in enumerate(v):
  365:             with validate_context(f'At index {i}'):
  366:                 inner_check(val)
  367:     return check_array_fn
  368: 
  369: 
  370: def check_and(*fns):
  371:     def check(v):
  372:         for fn in fns:
  373:             fn(v)
  374:     return check
  375: 
  376: 
  377: def validate(v, schema):
  378:     schema.check(v)
  379:     return v
  380: 
  381: 
  382: def apply_defaults(v, schema):
  383:     return schema.apply_defaults(v)
  384: 
  385: 
  386: def remove_defaults(v, schema):
  387:     return schema.remove_defaults(v)
  388: 
  389: 
  390: def load_from_filename(
  391:         filename,
  392:         schema,
  393:         load_strategy,
  394:         exc_tp=ValidationError,
  395:         *,
  396:         display_filename=None,
  397: ):
  398:     display_filename = display_filename or filename
  399:     with reraise_as(exc_tp):
  400:         if not os.path.isfile(filename):
  401:             raise ValidationError(f'{display_filename} is not a file')
  402: 
  403:         with validate_context(f'File {display_filename}'):
  404:             try:
  405:                 with open(filename, encoding='utf-8') as f:
  406:                     contents = f.read()
  407:             except UnicodeDecodeError as e:
  408:                 raise ValidationError(str(e))
  409: 
  410:             try:
  411:                 data = load_strategy(contents)
  412:             except Exception as e:
  413:                 raise ValidationError(str(e))
  414: 
  415:             validate(data, schema)
  416:             return apply_defaults(data, schema)
