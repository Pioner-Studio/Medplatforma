    1: # Copyright (c) 2010-2024 Benjamin Peterson
    2: #
    3: # Permission is hereby granted, free of charge, to any person obtaining a copy
    4: # of this software and associated documentation files (the "Software"), to deal
    5: # in the Software without restriction, including without limitation the rights
    6: # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    7: # copies of the Software, and to permit persons to whom the Software is
    8: # furnished to do so, subject to the following conditions:
    9: #
   10: # The above copyright notice and this permission notice shall be included in all
   11: # copies or substantial portions of the Software.
   12: #
   13: # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   14: # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   15: # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   16: # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   17: # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   18: # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   19: # SOFTWARE.
   20: 
   21: """Utilities for writing code that runs on Python 2 and 3"""
   22: 
   23: from __future__ import absolute_import
   24: 
   25: import functools
   26: import itertools
   27: import operator
   28: import sys
   29: import types
   30: 
   31: __author__ = "Benjamin Peterson <benjamin@python.org>"
   32: __version__ = "1.17.0"
   33: 
   34: 
   35: # Useful for very coarse version differentiation.
   36: PY2 = sys.version_info[0] == 2
   37: PY3 = sys.version_info[0] == 3
   38: PY34 = sys.version_info[0:2] >= (3, 4)
   39: 
   40: if PY3:
   41:     string_types = str,
   42:     integer_types = int,
   43:     class_types = type,
   44:     text_type = str
   45:     binary_type = bytes
   46: 
   47:     MAXSIZE = sys.maxsize
   48: else:
   49:     string_types = basestring,
   50:     integer_types = (int, long)
   51:     class_types = (type, types.ClassType)
   52:     text_type = unicode
   53:     binary_type = str
   54: 
   55:     if sys.platform.startswith("java"):
   56:         # Jython always uses 32 bits.
   57:         MAXSIZE = int((1 << 31) - 1)
   58:     else:
   59:         # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
   60:         class X(object):
   61: 
   62:             def __len__(self):
   63:                 return 1 << 31
   64:         try:
   65:             len(X())
   66:         except OverflowError:
   67:             # 32-bit
   68:             MAXSIZE = int((1 << 31) - 1)
   69:         else:
   70:             # 64-bit
   71:             MAXSIZE = int((1 << 63) - 1)
   72:         del X
   73: 
   74: if PY34:
   75:     from importlib.util import spec_from_loader
   76: else:
   77:     spec_from_loader = None
   78: 
   79: 
   80: def _add_doc(func, doc):
   81:     """Add documentation to a function."""
   82:     func.__doc__ = doc
   83: 
   84: 
   85: def _import_module(name):
   86:     """Import module, returning the module after the last dot."""
   87:     __import__(name)
   88:     return sys.modules[name]
   89: 
   90: 
   91: class _LazyDescr(object):
   92: 
   93:     def __init__(self, name):
   94:         self.name = name
   95: 
   96:     def __get__(self, obj, tp):
   97:         result = self._resolve()
   98:         setattr(obj, self.name, result)  # Invokes __set__.
   99:         try:
  100:             # This is a bit ugly, but it avoids running this again by
  101:             # removing this descriptor.
  102:             delattr(obj.__class__, self.name)
  103:         except AttributeError:
  104:             pass
  105:         return result
  106: 
  107: 
  108: class MovedModule(_LazyDescr):
  109: 
  110:     def __init__(self, name, old, new=None):
  111:         super(MovedModule, self).__init__(name)
  112:         if PY3:
  113:             if new is None:
  114:                 new = name
  115:             self.mod = new
  116:         else:
  117:             self.mod = old
  118: 
  119:     def _resolve(self):
  120:         return _import_module(self.mod)
  121: 
  122:     def __getattr__(self, attr):
  123:         _module = self._resolve()
  124:         value = getattr(_module, attr)
  125:         setattr(self, attr, value)
  126:         return value
  127: 
  128: 
  129: class _LazyModule(types.ModuleType):
  130: 
  131:     def __init__(self, name):
  132:         super(_LazyModule, self).__init__(name)
  133:         self.__doc__ = self.__class__.__doc__
  134: 
  135:     def __dir__(self):
  136:         attrs = ["__doc__", "__name__"]
  137:         attrs += [attr.name for attr in self._moved_attributes]
  138:         return attrs
  139: 
  140:     # Subclasses should override this
  141:     _moved_attributes = []
  142: 
  143: 
  144: class MovedAttribute(_LazyDescr):
  145: 
  146:     def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
  147:         super(MovedAttribute, self).__init__(name)
  148:         if PY3:
  149:             if new_mod is None:
  150:                 new_mod = name
  151:             self.mod = new_mod
  152:             if new_attr is None:
  153:                 if old_attr is None:
  154:                     new_attr = name
  155:                 else:
  156:                     new_attr = old_attr
  157:             self.attr = new_attr
  158:         else:
  159:             self.mod = old_mod
  160:             if old_attr is None:
  161:                 old_attr = name
  162:             self.attr = old_attr
  163: 
  164:     def _resolve(self):
  165:         module = _import_module(self.mod)
  166:         return getattr(module, self.attr)
  167: 
  168: 
  169: class _SixMetaPathImporter(object):
  170: 
  171:     """
  172:     A meta path importer to import six.moves and its submodules.
  173: 
  174:     This class implements a PEP302 finder and loader. It should be compatible
  175:     with Python 2.5 and all existing versions of Python3
  176:     """
  177: 
  178:     def __init__(self, six_module_name):
  179:         self.name = six_module_name
  180:         self.known_modules = {}
  181: 
  182:     def _add_module(self, mod, *fullnames):
  183:         for fullname in fullnames:
  184:             self.known_modules[self.name + "." + fullname] = mod
  185: 
  186:     def _get_module(self, fullname):
  187:         return self.known_modules[self.name + "." + fullname]
  188: 
  189:     def find_module(self, fullname, path=None):
  190:         if fullname in self.known_modules:
  191:             return self
  192:         return None
  193: 
  194:     def find_spec(self, fullname, path, target=None):
  195:         if fullname in self.known_modules:
  196:             return spec_from_loader(fullname, self)
  197:         return None
  198: 
  199:     def __get_module(self, fullname):
  200:         try:
  201:             return self.known_modules[fullname]
  202:         except KeyError:
  203:             raise ImportError("This loader does not know module " + fullname)
  204: 
  205:     def load_module(self, fullname):
  206:         try:
  207:             # in case of a reload
  208:             return sys.modules[fullname]
  209:         except KeyError:
  210:             pass
  211:         mod = self.__get_module(fullname)
  212:         if isinstance(mod, MovedModule):
  213:             mod = mod._resolve()
  214:         else:
  215:             mod.__loader__ = self
  216:         sys.modules[fullname] = mod
  217:         return mod
  218: 
  219:     def is_package(self, fullname):
  220:         """
  221:         Return true, if the named module is a package.
  222: 
  223:         We need this method to get correct spec objects with
  224:         Python 3.4 (see PEP451)
  225:         """
  226:         return hasattr(self.__get_module(fullname), "__path__")
  227: 
  228:     def get_code(self, fullname):
  229:         """Return None
  230: 
  231:         Required, if is_package is implemented"""
  232:         self.__get_module(fullname)  # eventually raises ImportError
  233:         return None
  234:     get_source = get_code  # same as get_code
  235: 
  236:     def create_module(self, spec):
  237:         return self.load_module(spec.name)
  238: 
  239:     def exec_module(self, module):
  240:         pass
  241: 
  242: _importer = _SixMetaPathImporter(__name__)
  243: 
  244: 
  245: class _MovedItems(_LazyModule):
  246: 
  247:     """Lazy loading of moved objects"""
  248:     __path__ = []  # mark as package
  249: 
  250: 
  251: _moved_attributes = [
  252:     MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
  253:     MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
  254:     MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
  255:     MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
  256:     MovedAttribute("intern", "__builtin__", "sys"),
  257:     MovedAttribute("map", "itertools", "builtins", "imap", "map"),
  258:     MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
  259:     MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
  260:     MovedAttribute("getoutput", "commands", "subprocess"),
  261:     MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
  262:     MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
  263:     MovedAttribute("reduce", "__builtin__", "functools"),
  264:     MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
  265:     MovedAttribute("StringIO", "StringIO", "io"),
  266:     MovedAttribute("UserDict", "UserDict", "collections", "IterableUserDict", "UserDict"),
  267:     MovedAttribute("UserList", "UserList", "collections"),
  268:     MovedAttribute("UserString", "UserString", "collections"),
  269:     MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
  270:     MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
  271:     MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
  272:     MovedModule("builtins", "__builtin__"),
  273:     MovedModule("configparser", "ConfigParser"),
  274:     MovedModule("collections_abc", "collections", "collections.abc" if sys.version_info >= (3, 3) else "collections"),
  275:     MovedModule("copyreg", "copy_reg"),
  276:     MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
  277:     MovedModule("dbm_ndbm", "dbm", "dbm.ndbm"),
  278:     MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread" if sys.version_info < (3, 9) else "_thread"),
  279:     MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
  280:     MovedModule("http_cookies", "Cookie", "http.cookies"),
  281:     MovedModule("html_entities", "htmlentitydefs", "html.entities"),
  282:     MovedModule("html_parser", "HTMLParser", "html.parser"),
  283:     MovedModule("http_client", "httplib", "http.client"),
  284:     MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
  285:     MovedModule("email_mime_image", "email.MIMEImage", "email.mime.image"),
  286:     MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
  287:     MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
  288:     MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
  289:     MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
  290:     MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
  291:     MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
  292:     MovedModule("cPickle", "cPickle", "pickle"),
  293:     MovedModule("queue", "Queue"),
  294:     MovedModule("reprlib", "repr"),
  295:     MovedModule("socketserver", "SocketServer"),
  296:     MovedModule("_thread", "thread", "_thread"),
  297:     MovedModule("tkinter", "Tkinter"),
  298:     MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
  299:     MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
  300:     MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
  301:     MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
  302:     MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
  303:     MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
  304:     MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
  305:     MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
  306:     MovedModule("tkinter_colorchooser", "tkColorChooser",
  307:                 "tkinter.colorchooser"),
  308:     MovedModule("tkinter_commondialog", "tkCommonDialog",
  309:                 "tkinter.commondialog"),
  310:     MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
  311:     MovedModule("tkinter_font", "tkFont", "tkinter.font"),
  312:     MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
  313:     MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
  314:                 "tkinter.simpledialog"),
  315:     MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
  316:     MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
  317:     MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
  318:     MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
  319:     MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
  320:     MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
  321: ]
  322: # Add windows specific modules.
  323: if sys.platform == "win32":
  324:     _moved_attributes += [
  325:         MovedModule("winreg", "_winreg"),
  326:     ]
  327: 
  328: for attr in _moved_attributes:
  329:     setattr(_MovedItems, attr.name, attr)
  330:     if isinstance(attr, MovedModule):
  331:         _importer._add_module(attr, "moves." + attr.name)
  332: del attr
  333: 
  334: _MovedItems._moved_attributes = _moved_attributes
  335: 
  336: moves = _MovedItems(__name__ + ".moves")
  337: _importer._add_module(moves, "moves")
  338: 
  339: 
  340: class Module_six_moves_urllib_parse(_LazyModule):
  341: 
  342:     """Lazy loading of moved objects in six.moves.urllib_parse"""
  343: 
  344: 
  345: _urllib_parse_moved_attributes = [
  346:     MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
  347:     MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
  348:     MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
  349:     MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
  350:     MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
  351:     MovedAttribute("urljoin", "urlparse", "urllib.parse"),
  352:     MovedAttribute("urlparse", "urlparse", "urllib.parse"),
  353:     MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
  354:     MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
  355:     MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
  356:     MovedAttribute("quote", "urllib", "urllib.parse"),
  357:     MovedAttribute("quote_plus", "urllib", "urllib.parse"),
  358:     MovedAttribute("unquote", "urllib", "urllib.parse"),
  359:     MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
  360:     MovedAttribute("unquote_to_bytes", "urllib", "urllib.parse", "unquote", "unquote_to_bytes"),
  361:     MovedAttribute("urlencode", "urllib", "urllib.parse"),
  362:     MovedAttribute("splitquery", "urllib", "urllib.parse"),
  363:     MovedAttribute("splittag", "urllib", "urllib.parse"),
  364:     MovedAttribute("splituser", "urllib", "urllib.parse"),
  365:     MovedAttribute("splitvalue", "urllib", "urllib.parse"),
  366:     MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
  367:     MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
  368:     MovedAttribute("uses_params", "urlparse", "urllib.parse"),
  369:     MovedAttribute("uses_query", "urlparse", "urllib.parse"),
  370:     MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
  371: ]
  372: for attr in _urllib_parse_moved_attributes:
  373:     setattr(Module_six_moves_urllib_parse, attr.name, attr)
  374: del attr
  375: 
  376: Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes
  377: 
  378: _importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
  379:                       "moves.urllib_parse", "moves.urllib.parse")
  380: 
  381: 
  382: class Module_six_moves_urllib_error(_LazyModule):
  383: 
  384:     """Lazy loading of moved objects in six.moves.urllib_error"""
  385: 
  386: 
  387: _urllib_error_moved_attributes = [
  388:     MovedAttribute("URLError", "urllib2", "urllib.error"),
  389:     MovedAttribute("HTTPError", "urllib2", "urllib.error"),
  390:     MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
  391: ]
  392: for attr in _urllib_error_moved_attributes:
  393:     setattr(Module_six_moves_urllib_error, attr.name, attr)
  394: del attr
  395: 
  396: Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes
  397: 
  398: _importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
  399:                       "moves.urllib_error", "moves.urllib.error")
  400: 
  401: 
  402: class Module_six_moves_urllib_request(_LazyModule):
  403: 
  404:     """Lazy loading of moved objects in six.moves.urllib_request"""
  405: 
  406: 
  407: _urllib_request_moved_attributes = [
  408:     MovedAttribute("urlopen", "urllib2", "urllib.request"),
  409:     MovedAttribute("install_opener", "urllib2", "urllib.request"),
  410:     MovedAttribute("build_opener", "urllib2", "urllib.request"),
  411:     MovedAttribute("pathname2url", "urllib", "urllib.request"),
  412:     MovedAttribute("url2pathname", "urllib", "urllib.request"),
  413:     MovedAttribute("getproxies", "urllib", "urllib.request"),
  414:     MovedAttribute("Request", "urllib2", "urllib.request"),
  415:     MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
  416:     MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
  417:     MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
  418:     MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
  419:     MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
  420:     MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
  421:     MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
  422:     MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
  423:     MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
  424:     MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
  425:     MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
  426:     MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
  427:     MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
  428:     MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
  429:     MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
  430:     MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
  431:     MovedAttribute("FileHandler", "urllib2", "urllib.request"),
  432:     MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
  433:     MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
  434:     MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
  435:     MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
  436:     MovedAttribute("urlretrieve", "urllib", "urllib.request"),
  437:     MovedAttribute("urlcleanup", "urllib", "urllib.request"),
  438:     MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
  439:     MovedAttribute("parse_http_list", "urllib2", "urllib.request"),
  440:     MovedAttribute("parse_keqv_list", "urllib2", "urllib.request"),
  441: ]
  442: if sys.version_info[:2] < (3, 14):
  443:     _urllib_request_moved_attributes.extend(
  444:         [
  445:             MovedAttribute("URLopener", "urllib", "urllib.request"),
  446:             MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
  447:         ]
  448:     )
  449: for attr in _urllib_request_moved_attributes:
  450:     setattr(Module_six_moves_urllib_request, attr.name, attr)
  451: del attr
  452: 
  453: Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes
  454: 
  455: _importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
  456:                       "moves.urllib_request", "moves.urllib.request")
  457: 
  458: 
  459: class Module_six_moves_urllib_response(_LazyModule):
  460: 
  461:     """Lazy loading of moved objects in six.moves.urllib_response"""
  462: 
  463: 
  464: _urllib_response_moved_attributes = [
  465:     MovedAttribute("addbase", "urllib", "urllib.response"),
  466:     MovedAttribute("addclosehook", "urllib", "urllib.response"),
  467:     MovedAttribute("addinfo", "urllib", "urllib.response"),
  468:     MovedAttribute("addinfourl", "urllib", "urllib.response"),
  469: ]
  470: for attr in _urllib_response_moved_attributes:
  471:     setattr(Module_six_moves_urllib_response, attr.name, attr)
  472: del attr
  473: 
  474: Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes
  475: 
  476: _importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
  477:                       "moves.urllib_response", "moves.urllib.response")
  478: 
  479: 
  480: class Module_six_moves_urllib_robotparser(_LazyModule):
  481: 
  482:     """Lazy loading of moved objects in six.moves.urllib_robotparser"""
  483: 
  484: 
  485: _urllib_robotparser_moved_attributes = [
  486:     MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
  487: ]
  488: for attr in _urllib_robotparser_moved_attributes:
  489:     setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
  490: del attr
  491: 
  492: Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes
  493: 
  494: _importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
  495:                       "moves.urllib_robotparser", "moves.urllib.robotparser")
  496: 
  497: 
  498: class Module_six_moves_urllib(types.ModuleType):
  499: 
  500:     """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
  501:     __path__ = []  # mark as package
  502:     parse = _importer._get_module("moves.urllib_parse")
  503:     error = _importer._get_module("moves.urllib_error")
  504:     request = _importer._get_module("moves.urllib_request")
  505:     response = _importer._get_module("moves.urllib_response")
  506:     robotparser = _importer._get_module("moves.urllib_robotparser")
  507: 
  508:     def __dir__(self):
  509:         return ['parse', 'error', 'request', 'response', 'robotparser']
  510: 
  511: _importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
  512:                       "moves.urllib")
  513: 
  514: 
  515: def add_move(move):
  516:     """Add an item to six.moves."""
  517:     setattr(_MovedItems, move.name, move)
  518: 
  519: 
  520: def remove_move(name):
  521:     """Remove item from six.moves."""
  522:     try:
  523:         delattr(_MovedItems, name)
  524:     except AttributeError:
  525:         try:
  526:             del moves.__dict__[name]
  527:         except KeyError:
  528:             raise AttributeError("no such move, %r" % (name,))
  529: 
  530: 
  531: if PY3:
  532:     _meth_func = "__func__"
  533:     _meth_self = "__self__"
  534: 
  535:     _func_closure = "__closure__"
  536:     _func_code = "__code__"
  537:     _func_defaults = "__defaults__"
  538:     _func_globals = "__globals__"
  539: else:
  540:     _meth_func = "im_func"
  541:     _meth_self = "im_self"
  542: 
  543:     _func_closure = "func_closure"
  544:     _func_code = "func_code"
  545:     _func_defaults = "func_defaults"
  546:     _func_globals = "func_globals"
  547: 
  548: 
  549: try:
  550:     advance_iterator = next
  551: except NameError:
  552:     def advance_iterator(it):
  553:         return it.next()
  554: next = advance_iterator
  555: 
  556: 
  557: try:
  558:     callable = callable
  559: except NameError:
  560:     def callable(obj):
  561:         return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)
  562: 
  563: 
  564: if PY3:
  565:     def get_unbound_function(unbound):
  566:         return unbound
  567: 
  568:     create_bound_method = types.MethodType
  569: 
  570:     def create_unbound_method(func, cls):
  571:         return func
  572: 
  573:     Iterator = object
  574: else:
  575:     def get_unbound_function(unbound):
  576:         return unbound.im_func
  577: 
  578:     def create_bound_method(func, obj):
  579:         return types.MethodType(func, obj, obj.__class__)
  580: 
  581:     def create_unbound_method(func, cls):
  582:         return types.MethodType(func, None, cls)
  583: 
  584:     class Iterator(object):
  585: 
  586:         def next(self):
  587:             return type(self).__next__(self)
  588: 
  589:     callable = callable
  590: _add_doc(get_unbound_function,
  591:          """Get the function out of a possibly unbound function""")
  592: 
  593: 
  594: get_method_function = operator.attrgetter(_meth_func)
  595: get_method_self = operator.attrgetter(_meth_self)
  596: get_function_closure = operator.attrgetter(_func_closure)
  597: get_function_code = operator.attrgetter(_func_code)
  598: get_function_defaults = operator.attrgetter(_func_defaults)
  599: get_function_globals = operator.attrgetter(_func_globals)
  600: 
  601: 
  602: if PY3:
  603:     def iterkeys(d, **kw):
  604:         return iter(d.keys(**kw))
  605: 
  606:     def itervalues(d, **kw):
  607:         return iter(d.values(**kw))
  608: 
  609:     def iteritems(d, **kw):
  610:         return iter(d.items(**kw))
  611: 
  612:     def iterlists(d, **kw):
  613:         return iter(d.lists(**kw))
  614: 
  615:     viewkeys = operator.methodcaller("keys")
  616: 
  617:     viewvalues = operator.methodcaller("values")
  618: 
  619:     viewitems = operator.methodcaller("items")
  620: else:
  621:     def iterkeys(d, **kw):
  622:         return d.iterkeys(**kw)
  623: 
  624:     def itervalues(d, **kw):
  625:         return d.itervalues(**kw)
  626: 
  627:     def iteritems(d, **kw):
  628:         return d.iteritems(**kw)
  629: 
  630:     def iterlists(d, **kw):
  631:         return d.iterlists(**kw)
  632: 
  633:     viewkeys = operator.methodcaller("viewkeys")
  634: 
  635:     viewvalues = operator.methodcaller("viewvalues")
  636: 
  637:     viewitems = operator.methodcaller("viewitems")
  638: 
  639: _add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
  640: _add_doc(itervalues, "Return an iterator over the values of a dictionary.")
  641: _add_doc(iteritems,
  642:          "Return an iterator over the (key, value) pairs of a dictionary.")
  643: _add_doc(iterlists,
  644:          "Return an iterator over the (key, [values]) pairs of a dictionary.")
  645: 
  646: 
  647: if PY3:
  648:     def b(s):
  649:         return s.encode("latin-1")
  650: 
  651:     def u(s):
  652:         return s
  653:     unichr = chr
  654:     import struct
  655:     int2byte = struct.Struct(">B").pack
  656:     del struct
  657:     byte2int = operator.itemgetter(0)
  658:     indexbytes = operator.getitem
  659:     iterbytes = iter
  660:     import io
  661:     StringIO = io.StringIO
  662:     BytesIO = io.BytesIO
  663:     del io
  664:     _assertCountEqual = "assertCountEqual"
  665:     if sys.version_info[1] <= 1:
  666:         _assertRaisesRegex = "assertRaisesRegexp"
  667:         _assertRegex = "assertRegexpMatches"
  668:         _assertNotRegex = "assertNotRegexpMatches"
  669:     else:
  670:         _assertRaisesRegex = "assertRaisesRegex"
  671:         _assertRegex = "assertRegex"
  672:         _assertNotRegex = "assertNotRegex"
  673: else:
  674:     def b(s):
  675:         return s
  676:     # Workaround for standalone backslash
  677: 
  678:     def u(s):
  679:         return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
  680:     unichr = unichr
  681:     int2byte = chr
  682: 
  683:     def byte2int(bs):
  684:         return ord(bs[0])
  685: 
  686:     def indexbytes(buf, i):
  687:         return ord(buf[i])
  688:     iterbytes = functools.partial(itertools.imap, ord)
  689:     import StringIO
  690:     StringIO = BytesIO = StringIO.StringIO
  691:     _assertCountEqual = "assertItemsEqual"
  692:     _assertRaisesRegex = "assertRaisesRegexp"
  693:     _assertRegex = "assertRegexpMatches"
  694:     _assertNotRegex = "assertNotRegexpMatches"
  695: _add_doc(b, """Byte literal""")
  696: _add_doc(u, """Text literal""")
  697: 
  698: 
  699: def assertCountEqual(self, *args, **kwargs):
  700:     return getattr(self, _assertCountEqual)(*args, **kwargs)
  701: 
  702: 
  703: def assertRaisesRegex(self, *args, **kwargs):
  704:     return getattr(self, _assertRaisesRegex)(*args, **kwargs)
  705: 
  706: 
  707: def assertRegex(self, *args, **kwargs):
  708:     return getattr(self, _assertRegex)(*args, **kwargs)
  709: 
  710: 
  711: def assertNotRegex(self, *args, **kwargs):
  712:     return getattr(self, _assertNotRegex)(*args, **kwargs)
  713: 
  714: 
  715: if PY3:
  716:     exec_ = getattr(moves.builtins, "exec")
  717: 
  718:     def reraise(tp, value, tb=None):
  719:         try:
  720:             if value is None:
  721:                 value = tp()
  722:             if value.__traceback__ is not tb:
  723:                 raise value.with_traceback(tb)
  724:             raise value
  725:         finally:
  726:             value = None
  727:             tb = None
  728: 
  729: else:
  730:     def exec_(_code_, _globs_=None, _locs_=None):
  731:         """Execute code in a namespace."""
  732:         if _globs_ is None:
  733:             frame = sys._getframe(1)
  734:             _globs_ = frame.f_globals
  735:             if _locs_ is None:
  736:                 _locs_ = frame.f_locals
  737:             del frame
  738:         elif _locs_ is None:
  739:             _locs_ = _globs_
  740:         exec("""exec _code_ in _globs_, _locs_""")
  741: 
  742:     exec_("""def reraise(tp, value, tb=None):
  743:     try:
  744:         raise tp, value, tb
  745:     finally:
  746:         tb = None
  747: """)
  748: 
  749: 
  750: if sys.version_info[:2] > (3,):
  751:     exec_("""def raise_from(value, from_value):
  752:     try:
  753:         raise value from from_value
  754:     finally:
  755:         value = None
  756: """)
  757: else:
  758:     def raise_from(value, from_value):
  759:         raise value
  760: 
  761: 
  762: print_ = getattr(moves.builtins, "print", None)
  763: if print_ is None:
  764:     def print_(*args, **kwargs):
  765:         """The new-style print function for Python 2.4 and 2.5."""
  766:         fp = kwargs.pop("file", sys.stdout)
  767:         if fp is None:
  768:             return
  769: 
  770:         def write(data):
  771:             if not isinstance(data, basestring):
  772:                 data = str(data)
  773:             # If the file has an encoding, encode unicode with it.
  774:             if (isinstance(fp, file) and
  775:                     isinstance(data, unicode) and
  776:                     fp.encoding is not None):
  777:                 errors = getattr(fp, "errors", None)
  778:                 if errors is None:
  779:                     errors = "strict"
  780:                 data = data.encode(fp.encoding, errors)
  781:             fp.write(data)
  782:         want_unicode = False
  783:         sep = kwargs.pop("sep", None)
  784:         if sep is not None:
  785:             if isinstance(sep, unicode):
  786:                 want_unicode = True
  787:             elif not isinstance(sep, str):
  788:                 raise TypeError("sep must be None or a string")
  789:         end = kwargs.pop("end", None)
  790:         if end is not None:
  791:             if isinstance(end, unicode):
  792:                 want_unicode = True
  793:             elif not isinstance(end, str):
  794:                 raise TypeError("end must be None or a string")
  795:         if kwargs:
  796:             raise TypeError("invalid keyword arguments to print()")
  797:         if not want_unicode:
  798:             for arg in args:
  799:                 if isinstance(arg, unicode):
  800:                     want_unicode = True
  801:                     break
  802:         if want_unicode:
  803:             newline = unicode("\n")
  804:             space = unicode(" ")
  805:         else:
  806:             newline = "\n"
  807:             space = " "
  808:         if sep is None:
  809:             sep = space
  810:         if end is None:
  811:             end = newline
  812:         for i, arg in enumerate(args):
  813:             if i:
  814:                 write(sep)
  815:             write(arg)
  816:         write(end)
  817: if sys.version_info[:2] < (3, 3):
  818:     _print = print_
  819: 
  820:     def print_(*args, **kwargs):
  821:         fp = kwargs.get("file", sys.stdout)
  822:         flush = kwargs.pop("flush", False)
  823:         _print(*args, **kwargs)
  824:         if flush and fp is not None:
  825:             fp.flush()
  826: 
  827: _add_doc(reraise, """Reraise an exception.""")
  828: 
  829: if sys.version_info[0:2] < (3, 4):
  830:     # This does exactly the same what the :func:`py3:functools.update_wrapper`
  831:     # function does on Python versions after 3.2. It sets the ``__wrapped__``
  832:     # attribute on ``wrapper`` object and it doesn't raise an error if any of
  833:     # the attributes mentioned in ``assigned`` and ``updated`` are missing on
  834:     # ``wrapped`` object.
  835:     def _update_wrapper(wrapper, wrapped,
  836:                         assigned=functools.WRAPPER_ASSIGNMENTS,
  837:                         updated=functools.WRAPPER_UPDATES):
  838:         for attr in assigned:
  839:             try:
  840:                 value = getattr(wrapped, attr)
  841:             except AttributeError:
  842:                 continue
  843:             else:
  844:                 setattr(wrapper, attr, value)
  845:         for attr in updated:
  846:             getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
  847:         wrapper.__wrapped__ = wrapped
  848:         return wrapper
  849:     _update_wrapper.__doc__ = functools.update_wrapper.__doc__
  850: 
  851:     def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
  852:               updated=functools.WRAPPER_UPDATES):
  853:         return functools.partial(_update_wrapper, wrapped=wrapped,
  854:                                  assigned=assigned, updated=updated)
  855:     wraps.__doc__ = functools.wraps.__doc__
  856: 
  857: else:
  858:     wraps = functools.wraps
  859: 
  860: 
  861: def with_metaclass(meta, *bases):
  862:     """Create a base class with a metaclass."""
  863:     # This requires a bit of explanation: the basic idea is to make a dummy
  864:     # metaclass for one level of class instantiation that replaces itself with
  865:     # the actual metaclass.
  866:     class metaclass(type):
  867: 
  868:         def __new__(cls, name, this_bases, d):
  869:             if sys.version_info[:2] >= (3, 7):
  870:                 # This version introduced PEP 560 that requires a bit
  871:                 # of extra care (we mimic what is done by __build_class__).
  872:                 resolved_bases = types.resolve_bases(bases)
  873:                 if resolved_bases is not bases:
  874:                     d['__orig_bases__'] = bases
  875:             else:
  876:                 resolved_bases = bases
  877:             return meta(name, resolved_bases, d)
  878: 
  879:         @classmethod
  880:         def __prepare__(cls, name, this_bases):
  881:             return meta.__prepare__(name, bases)
  882:     return type.__new__(metaclass, 'temporary_class', (), {})
  883: 
  884: 
  885: def add_metaclass(metaclass):
  886:     """Class decorator for creating a class with a metaclass."""
  887:     def wrapper(cls):
  888:         orig_vars = cls.__dict__.copy()
  889:         slots = orig_vars.get('__slots__')
  890:         if slots is not None:
  891:             if isinstance(slots, str):
  892:                 slots = [slots]
  893:             for slots_var in slots:
  894:                 orig_vars.pop(slots_var)
  895:         orig_vars.pop('__dict__', None)
  896:         orig_vars.pop('__weakref__', None)
  897:         if hasattr(cls, '__qualname__'):
  898:             orig_vars['__qualname__'] = cls.__qualname__
  899:         return metaclass(cls.__name__, cls.__bases__, orig_vars)
  900:     return wrapper
  901: 
  902: 
  903: def ensure_binary(s, encoding='utf-8', errors='strict'):
  904:     """Coerce **s** to six.binary_type.
  905: 
  906:     For Python 2:
  907:       - `unicode` -> encoded to `str`
  908:       - `str` -> `str`
  909: 
  910:     For Python 3:
  911:       - `str` -> encoded to `bytes`
  912:       - `bytes` -> `bytes`
  913:     """
  914:     if isinstance(s, binary_type):
  915:         return s
  916:     if isinstance(s, text_type):
  917:         return s.encode(encoding, errors)
  918:     raise TypeError("not expecting type '%s'" % type(s))
  919: 
  920: 
  921: def ensure_str(s, encoding='utf-8', errors='strict'):
  922:     """Coerce *s* to `str`.
  923: 
  924:     For Python 2:
  925:       - `unicode` -> encoded to `str`
  926:       - `str` -> `str`
  927: 
  928:     For Python 3:
  929:       - `str` -> `str`
  930:       - `bytes` -> decoded to `str`
  931:     """
  932:     # Optimization: Fast return for the common case.
  933:     if type(s) is str:
  934:         return s
  935:     if PY2 and isinstance(s, text_type):
  936:         return s.encode(encoding, errors)
  937:     elif PY3 and isinstance(s, binary_type):
  938:         return s.decode(encoding, errors)
  939:     elif not isinstance(s, (text_type, binary_type)):
  940:         raise TypeError("not expecting type '%s'" % type(s))
  941:     return s
  942: 
  943: 
  944: def ensure_text(s, encoding='utf-8', errors='strict'):
  945:     """Coerce *s* to six.text_type.
  946: 
  947:     For Python 2:
  948:       - `unicode` -> `unicode`
  949:       - `str` -> `unicode`
  950: 
  951:     For Python 3:
  952:       - `str` -> `str`
  953:       - `bytes` -> decoded to `str`
  954:     """
  955:     if isinstance(s, binary_type):
  956:         return s.decode(encoding, errors)
  957:     elif isinstance(s, text_type):
  958:         return s
  959:     else:
  960:         raise TypeError("not expecting type '%s'" % type(s))
  961: 
  962: 
  963: def python_2_unicode_compatible(klass):
  964:     """
  965:     A class decorator that defines __unicode__ and __str__ methods under Python 2.
  966:     Under Python 3 it does nothing.
  967: 
  968:     To support Python 2 and 3 with a single code base, define a __str__ method
  969:     returning text and apply this decorator to the class.
  970:     """
  971:     if PY2:
  972:         if '__str__' not in klass.__dict__:
  973:             raise ValueError("@python_2_unicode_compatible cannot be applied "
  974:                              "to %s because it doesn't define __str__()." %
  975:                              klass.__name__)
  976:         klass.__unicode__ = klass.__str__
  977:         klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
  978:     return klass
  979: 
  980: 
  981: # Complete the moves implementation.
  982: # This code is at the end of this module to speed up module loading.
  983: # Turn this module into a package.
  984: __path__ = []  # required for PEP 302 and PEP 451
  985: __package__ = __name__  # see PEP 366 @ReservedAssignment
  986: if globals().get("__spec__") is not None:
  987:     __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
  988: # Remove other six meta path importers, since they cause problems. This can
  989: # happen if six is removed from sys.modules and then reloaded. (Setuptools does
  990: # this for some reason.)
  991: if sys.meta_path:
  992:     for i, importer in enumerate(sys.meta_path):
  993:         # Here's some real nastiness: Another "instance" of the six module might
  994:         # be floating around. Therefore, we can't use isinstance() to check for
  995:         # the six meta path importer, since the other six instance will have
  996:         # inserted an importer with different class.
  997:         if (type(importer).__name__ == "_SixMetaPathImporter" and
  998:                 importer.name == __name__):
  999:             del sys.meta_path[i]
 1000:             break
 1001:     del i, importer
 1002: # Finally, add the importer to the meta path import hook.
 1003: sys.meta_path.append(_importer)
